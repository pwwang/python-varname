{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>  []15 []13 []13 </p> <p>Dark magics about variable names in python</p> <p>CHANGELOG | API | Playground | :fire: StackOverflow answer</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U varname\n</code></pre> <p>Note if you use <code>python &lt; 3.8</code>, install <code>varname &lt; 0.11</code></p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Core features:</p> </li> <li> <p>Retrieving names of variables a function/class call is assigned to from inside it, using <code>varname</code>.</p> </li> <li>Detecting next immediate attribute name, using <code>will</code></li> <li> <p>Fetching argument names/sources passed to a function using <code>argname</code></p> </li> <li> <p>Other helper APIs (built based on core features):</p> </li> <li> <p>A value wrapper to store the variable name that a value is assigned to, using <code>Wrapper</code></p> </li> <li>A decorator to register <code>__varname__</code> to functions/classes, using <code>register</code></li> <li>A helper function to create dict without explicitly specifying the key-value pairs, using <code>jsobj</code></li> <li>A <code>debug</code> function to print variables with their names and values</li> <li><code>exec_code</code> to replace <code>exec</code> where source code is available at runtime</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>Thanks goes to these awesome people/projects:</p> <sub>executing</sub> <sub>@alexmojaki</sub> <sub>@breuleux</sub> <sub>@ElCuboNegro</sub> <sub>@thewchan</sub> <sub>@LawsOfSympathy</sub> <sub>@elliotgunton</sub> <p>Special thanks to @HanyuuLu to give up the name <code>varname</code> in pypi for this project.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#retrieving-the-variable-names-using-varname","title":"Retrieving the variable names using <code>varname(...)</code>","text":"<ul> <li> <p>From inside a function</p> <pre><code>from varname import varname\ndef function():\n    return varname()\n\nfunc = function()  # func == 'func'\n</code></pre> <p>When there are intermediate frames:</p> <pre><code>def wrapped():\n    return function()\n\ndef function():\n    # retrieve the variable name at the 2nd frame from this one\n    return varname(frame=2)\n\nfunc = wrapped() # func == 'func'\n</code></pre> <p>Or use <code>ignore</code> to ignore the wrapped frame:</p> <pre><code>def wrapped():\n    return function()\n\ndef function():\n    return varname(ignore=wrapped)\n\nfunc = wrapped() # func == 'func'\n</code></pre> <p>Calls from standard libraries are ignored by default:</p> <pre><code>import asyncio\n\nasync def function():\n    return varname()\n\nfunc = asyncio.run(function()) # func == 'func'\n</code></pre> <p>Use <code>strict</code> to control whether the call should be assigned to the variable directly:</p> <pre><code>def function(strict):\n    return varname(strict=strict)\n\nfunc = function(True)     # OK, direct assignment, func == 'func'\n\nfunc = [function(True)]   # Not a direct assignment, raises ImproperUseError\nfunc = [function(False)]  # OK, func == ['func']\n\nfunc = function(False), function(False)   # OK, func = ('func', 'func')\n</code></pre> </li> <li> <p>Retrieving name of a class instance</p> <pre><code>class Foo:\n    def __init__(self):\n        self.id = varname()\n\n    def copy(self):\n        # also able to fetch inside a method call\n        copied = Foo() # copied.id == 'copied'\n        copied.id = varname() # assign id to whatever variable name\n        return copied\n\nfoo = Foo()   # foo.id == 'foo'\n\nfoo2 = foo.copy() # foo2.id == 'foo2'\n</code></pre> </li> <li> <p>Multiple variables on Left-hand side</p> <pre><code># since v0.5.4\ndef func():\n    return varname(multi_vars=True)\n\na = func() # a == ('a',)\na, b = func() # (a, b) == ('a', 'b')\n[a, b] = func() # (a, b) == ('a', 'b')\n\n# hierarchy is also possible\na, (b, c) = func() # (a, b, c) == ('a', 'b', 'c')\n</code></pre> </li> <li> <p>Some unusual use</p> <pre><code>def function(**kwargs):\n    return varname(strict=False)\n\nfunc = func1 = function()  # func == func1 == 'func1'\n# if varname &lt; 0.8: func == func1 == 'func'\n# a warning will be shown\n# since you may not want func to be 'func1'\n\nx = function(y = function())  # x == 'x'\n\n# get part of the name\nfunc_abc = function()[-3:]  # func_abc == 'abc'\n\n# function alias supported now\nfunction2 = function\nfunc = function2()  # func == 'func'\n\na = lambda: 0\na.b = function() # a.b == 'a.b'\n</code></pre> </li> </ul>"},{"location":"#the-decorator-way-to-register-__varname__-to-functionsclasses","title":"The decorator way to register <code>__varname__</code> to functions/classes","text":"<ul> <li> <p>Registering <code>__varname__</code> to functions</p> <pre><code>from varname.helpers import register\n\n@register\ndef function():\n    return __varname__\n\nfunc = function() # func == 'func'\n</code></pre> <pre><code># arguments also allowed (frame, ignore and raise_exc)\n@register(frame=2)\ndef function():\n    return __varname__\n\ndef wrapped():\n    return function()\n\nfunc = wrapped() # func == 'func'\n</code></pre> </li> <li> <p>Registering <code>__varname__</code> as a class property</p> <pre><code>@register\nclass Foo:\n    ...\n\nfoo = Foo()\n# foo.__varname__ == 'foo'\n</code></pre> </li> </ul>"},{"location":"#getting-variable-names-directly-using-nameof","title":"Getting variable names directly using <code>nameof</code>","text":"<pre><code>from varname import varname, nameof\n\na = 1\nnameof(a) # 'a'\n\nb = 2\nnameof(a, b) # ('a', 'b')\n\ndef func():\n    return varname() + '_suffix'\n\nf = func() # f == 'f_suffix'\nnameof(f)  # 'f'\n\n# get full names of (chained) attribute calls\nfunc.a = func\nnameof(func.a, vars_only=False) # 'func.a'\n\nfunc.a.b = 1\nnameof(func.a.b, vars_only=False) # 'func.a.b'\n</code></pre>"},{"location":"#detecting-next-immediate-attribute-name","title":"Detecting next immediate attribute name","text":"<pre><code>from varname import will\nclass AwesomeClass:\n    def __init__(self):\n        self.will = None\n\n    def permit(self):\n        self.will = will(raise_exc=False)\n        if self.will == 'do':\n            # let self handle do\n            return self\n        raise AttributeError('Should do something with AwesomeClass object')\n\n    def do(self):\n        if self.will != 'do':\n            raise AttributeError(\"You don't have permission to do\")\n        return 'I am doing!'\n\nawesome = AwesomeClass()\nawesome.do() # AttributeError: You don't have permission to do\nawesome.permit() # AttributeError: Should do something with AwesomeClass object\nawesome.permit().do() == 'I am doing!'\n</code></pre>"},{"location":"#fetching-argument-namessources-using-argname","title":"Fetching argument names/sources using <code>argname</code>","text":"<pre><code>from varname import argname\n\ndef func(a, b=1):\n    print(argname('a'))\n\nx = y = z = 2\nfunc(x) # prints: x\n\n\ndef func2(a, b=1):\n    print(argname('a', 'b'))\nfunc2(y, b=x) # prints: ('y', 'x')\n\n\n# allow expressions\ndef func3(a, b=1):\n    print(argname('a', 'b', vars_only=False))\nfunc3(x+y, y+x) # prints: ('x+y', 'y+x')\n\n\n# positional and keyword arguments\ndef func4(*args, **kwargs):\n    print(argname('args[1]', 'kwargs[c]'))\nfunc4(y, x, c=z) # prints: ('x', 'z')\n\n\n# As of 0.9.0 (see: https://pwwang.github.io/python-varname/CHANGELOG/#v090)\n# Can also fetch the source of the argument for\n# __getattr__/__getitem__/__setattr/__setitem__/__add__/__lt__, etc.\nclass Foo:\n    def __setattr__(self, name, value):\n        print(argname(\"name\", \"value\", func=self.__setattr__))\n\nFoo().a = 1 # prints: (\"'a'\", '1')\n</code></pre>"},{"location":"#value-wrapper","title":"Value wrapper","text":"<pre><code>from varname.helpers import Wrapper\n\nfoo = Wrapper(True)\n# foo.name == 'foo'\n# foo.value == True\nbar = Wrapper(False)\n# bar.name == 'bar'\n# bar.value == False\n\ndef values_to_dict(*args):\n    return {val.name: val.value for val in args}\n\nmydict = values_to_dict(foo, bar)\n# {'foo': True, 'bar': False}\n</code></pre>"},{"location":"#creating-dictionary-using-jsobj","title":"Creating dictionary using <code>jsobj</code>","text":"<pre><code>from varname.helpers import jsobj\n\na = 1\nb = 2\njsobj(a, b) # {'a': 1, 'b': 2}\njsobj(a, b, c=3) # {'a': 1, 'b': 2, 'c': 3}\n</code></pre>"},{"location":"#debugging-with-debug","title":"Debugging with <code>debug</code>","text":"<pre><code>from varname.helpers import debug\n\na = 'value'\nb = ['val']\ndebug(a)\n# \"DEBUG: a='value'\\n\"\ndebug(b)\n# \"DEBUG: b=['val']\\n\"\ndebug(a, b)\n# \"DEBUG: a='value'\\nDEBUG: b=['val']\\n\"\ndebug(a, b, merge=True)\n# \"DEBUG: a='value', b=['val']\\n\"\ndebug(a, repr=False, prefix='')\n# 'a=value\\n'\n# also debug an expression\ndebug(a+a)\n# \"DEBUG: a+a='valuevalue'\\n\"\n# If you want to disable it:\ndebug(a+a, vars_only=True) # ImproperUseError\n</code></pre>"},{"location":"#replacing-exec-with-exec_code","title":"Replacing <code>exec</code> with <code>exec_code</code>","text":"<pre><code>from varname import argname\nfrom varname.helpers import exec_code\n\nclass Obj:\n    def __init__(self):\n        self.argnames = []\n\n    def receive(self, arg):\n        self.argnames.append(argname('arg', func=self.receive))\n\nobj = Obj()\n# exec('obj.receive(1)')  # Error\nexec_code('obj.receive(1)')\nexec_code('obj.receive(2)')\nobj.argnames # ['1', '2']\n</code></pre>"},{"location":"#reliability-and-limitations","title":"Reliability and limitations","text":"<p><code>varname</code> is all depending on <code>executing</code> package to look for the node. The node <code>executing</code> detects is ensured to be the correct one (see this).</p> <p>It partially works with environments where other AST magics apply, including <code>exec</code> function, <code>macropy</code>, <code>birdseye</code>, <code>reticulate</code> with <code>R</code>, etc. Neither <code>executing</code> nor <code>varname</code> is 100% working with those environments. Use it at your own risk.</p> <p>For example:</p> <ul> <li>This will not work:</li> </ul> <pre><code>from varname import argname\n\ndef getname(x):\n    print(argname(\"x\"))\n\na = 1\nexec(\"getname(a)\")  # Cannot retrieve the node where the function is called.\n\n## instead\n# from varname.helpers import exec_code\n# exec_code(\"getname(a)\")\n</code></pre>"},{"location":"CHANGELOG/","title":"Change Log","text":""},{"location":"CHANGELOG/#change-log","title":"Change Log","text":""},{"location":"CHANGELOG/#0150","title":"0.15.0","text":"<ul> <li>revert: bring nameof back (#117)</li> </ul>"},{"location":"CHANGELOG/#0140","title":"0.14.0","text":"<ul> <li>BREAKING CHANGE: deprecate nameof (see https://github.com/pwwang/python-varname/issues/117#issuecomment-2558358294)</li> <li>docs: remove deprecated nameof examples from README</li> <li>chore(deps): update asttokens to version 3.0.0 and adjust dependencies</li> <li>style: clean up unused imports and add spacing for readability for test files</li> <li>ci: update build workflow to use Ubuntu 24.04 and adjust Python version conditions</li> <li>chore(deps): add ipykernel dev dependency version 6.29.5 to run playground notebook</li> <li>chore(deps): update content-hash in poetry.lock after dependency changes</li> </ul>"},{"location":"CHANGELOG/#0135","title":"0.13.5","text":"<ul> <li>deps: bump up executing to ^2.1 to fix issues with python3.13</li> </ul>"},{"location":"CHANGELOG/#0134","title":"0.13.4","text":"<ul> <li>core: switch to poetry-core (#113)</li> <li>deps: bump up dependencies</li> <li>feat: support python 3.13 (#116)</li> <li>ci: use latest CI actions</li> <li>DEPRECATED: add warning to deprecate nameof in the future</li> </ul>"},{"location":"CHANGELOG/#0133","title":"0.13.3","text":"<ul> <li>feat: support frame to allow wrapping for <code>helpers.jsobj()</code> (#111)</li> </ul>"},{"location":"CHANGELOG/#0132","title":"0.13.2","text":"<ul> <li>deps: bump up pytest to v8</li> <li>feat: support vars_only to keep parents of an attribute for <code>helpers.jsobj()</code> (#110)</li> </ul>"},{"location":"CHANGELOG/#0131","title":"0.13.1","text":"<ul> <li>style: create py.typed for mypy compatibility (#109)</li> </ul>"},{"location":"CHANGELOG/#0130","title":"0.13.0","text":"<ul> <li>style: change max line length to 88</li> <li>style: clean up test code styles</li> <li>feat: support subscript node for varname (#104)</li> <li>ci: remove python3.8 from CI</li> <li>breaking!: <code>varname</code> of <code>a.b</code> now returns <code>\"a.b\"</code> instead of <code>\"a\"</code></li> </ul>"},{"location":"CHANGELOG/#0122","title":"0.12.2","text":"<ul> <li>Add <code>helpers.exec_code</code> function to replace <code>exec</code> so that source code available at runtime</li> </ul>"},{"location":"CHANGELOG/#0121","title":"0.12.1","text":"<ul> <li>Bump executing to 2.0.1</li> </ul>"},{"location":"CHANGELOG/#v0120","title":"v0.12.0","text":"<ul> <li>Support python 3.12</li> <li>Update python3.12 to CI</li> <li>Bump executing to ^2.0</li> <li>Bump up other dependencies</li> <li>Add Dockerfile for codesandbox</li> </ul>"},{"location":"CHANGELOG/#v0112","title":"v0.11.2","text":"<ul> <li> <p>\u2728 Add <code>jsobj</code> to create dict without explicitly specifying the key-value pairs</p> <pre><code>from varname.helpers import jsobj\n\na = 1\nb = 2\n# before\ndict(a=a, b=b, c=3)  # {'a': 1, 'b': 2, 'c': 3}\n\n# after\njsobj(a, b, c=3)  # {'a': 1, 'b': 2, 'c': 3}\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/#v0111","title":"v0.11.1","text":"<ul> <li>\u2728 Support starred variable for varname() (#96)</li> <li>\u2705 Fix tests</li> <li>\ud83d\udcdd Update docs for <code>varname(strict=...)</code></li> </ul>"},{"location":"CHANGELOG/#v0110","title":"v0.11.0","text":"<ul> <li>\ud83d\udcdd Update README for shields badges (#91)</li> <li>\ud83c\udff7\ufe0f Overload types for nameof and argname (#77)</li> <li>\ud83d\udca5 Drop python &lt;3.8  for v0.11      If you need support for python &lt;3.8, please use varname &lt;0.11</li> </ul>"},{"location":"CHANGELOG/#v0100","title":"v0.10.0","text":"<ul> <li>\u2728 Support python 3.11</li> </ul>"},{"location":"CHANGELOG/#v091","title":"v0.9.1","text":"<ul> <li>\u2b06\ufe0f Upgrade executing to 1.0</li> </ul>"},{"location":"CHANGELOG/#v090","title":"v0.9.0","text":"<ul> <li>\u2b06\ufe0f Upgrade executing to 0.9</li> <li>\ud83d\uddd1\ufe0f Remove deprecated <code>argname2</code></li> <li>\u2728 Support constants for <code>argname</code> even when <code>vars_only=True</code></li> <li> <p>\u2728 Support <code>__getattr__/__setattr__</code> etc for <code>argname</code></p> <p>Now you can do:</p> <pre><code>from varname import argname\n\nclass Foo:\n    def __getattr__(self, name):\n        \"\"\"Similar for `__getitem__`\"\"\"\n        print(argname(\"name\"))\n\n    def __setattr__(self, name, value):\n        \"\"\"Similar for `__setitem__`\"\"\"\n        print(argname(\"name\"))\n        print(argname(\"value\"))\n\n    def __add__(self, other):\n        \"\"\"Similar for `__sub__`, `__mul__`, `__truediv__`, `__floordiv__`,\n        `__mod__`, `__pow__`, `__lshift__`, `__rshift__`, `__matmul__`,\n        `__and__`, `__xor__`, `__or__`\n        \"\"\"\n        print(argname(\"other\"))\n\n    def __eq__(self, other):\n        \"\"\"Similar for `__lt__`, `__le__`, `__gt__`, `__ge__`, `__ne__`\n        \"\"\"\n        print(argname(\"other\"))\n\nfoo = Foo()\nb = 1\nfoo.x  # prints: 'x' (note the quotes)\nfoo.x = b  # prints: 'x' and b\nfoo + b  # prints: b\nfoo == b  # prints: b\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/#v083","title":"v0.8.3","text":"<p>This is more of a housekeeping release:</p> <ul> <li>\u2b06\ufe0f Upgrade <code>executing</code> to 0.8.3 to make varname work with ipython 8+</li> <li>\ud83d\udcdd Update <code>README.md</code> to add new contributors</li> <li>\ud83d\udea8 Use <code>flake8</code> instead of <code>pylint</code> for linting</li> </ul>"},{"location":"CHANGELOG/#v082","title":"v0.8.2","text":""},{"location":"CHANGELOG/#fixes","title":"Fixes","text":"<ul> <li>\ud83e\ude79 Use sysconfig instead of distutils.sysconfig to avoid deprecatewarning for python 3.10+</li> </ul>"},{"location":"CHANGELOG/#housekeeping","title":"Housekeeping","text":"<ul> <li>\ud83d\udc77 Add python3.10 in CI</li> <li>\ud83d\udcc4 Add license back</li> </ul>"},{"location":"CHANGELOG/#v081","title":"v0.8.1","text":"<ul> <li>Handle inspect raises \"could not get source code\" when printing rich exception message</li> </ul>"},{"location":"CHANGELOG/#v080","title":"v0.8.0","text":"<p>Compared to <code>v0.7.3</code></p> <ul> <li>Add <code>UsingExecWarning</code> when <code>exec</code> is used to retrieve <code>func</code> for <code>argname()</code>.</li> <li>Remove <code>NonVariableArgumentError</code>. Use <code>ImproperUseError</code> instead.</li> <li>Add <code>VarnameError</code> and <code>VarnameWarning</code> as root for varname-related exceptions and warnings, respectively.</li> <li>Default <code>strict</code> to <code>True</code> for <code>varname()</code>, <code>helpers.register()</code> and <code>helpers.Wrapper()</code></li> <li>Limit number of context lines for showing where <code>ImproperUseError</code> happens</li> </ul> <p>Compared to <code>v0.7.0</code></p> <ul> <li>Add <code>UsingExecWarning</code> when <code>exec</code> is used to retrieve <code>func</code> for <code>argname()</code>.</li> <li>Remove <code>NonVariableArgumentError</code>. Use <code>ImproperUseError</code> instead.</li> <li>Add <code>VarnameError</code> and <code>VarnameWarning</code> as root for varname-related exceptions and warnings, respectively.</li> <li>Add <code>strict</code> mode to <code>varname()</code>, <code>helpers.register()</code> and <code>helpers.Wrapper()</code> (#57)</li> <li>Support the walrus operator (<code>:=</code>) (#58)</li> <li>Change <code>argname()</code> to accept argument names instead of arguments themselves</li> <li>Remove <code>pos_only</code> argument from <code>argname()</code></li> <li>Add <code>ignore</code> argument to <code>argname()</code> to ignore intermediate frames</li> <li>Limit <code>VarnameRetrievingError</code> to the situations only when the AST node is not able to be retrieved.</li> </ul>"},{"location":"CHANGELOG/#v073","title":"v0.7.3","text":"<ul> <li>Indicate where the <code>ImproperUseError</code> happens for <code>varname()</code> (Close #60)</li> <li>Add <code>VarnameException</code> and <code>VarnameWarning</code> as root for all varname-defined exceptions and warnings.</li> </ul>"},{"location":"CHANGELOG/#v072","title":"v0.7.2","text":"<ul> <li>Add <code>strict</code> mode to <code>varname()</code> (#57)</li> <li>Support the walrus operator (<code>:=</code>) (#58)</li> </ul>"},{"location":"CHANGELOG/#v071","title":"v0.7.1","text":"<ul> <li>Add <code>ignore</code> argument to <code>argname2()</code></li> <li>Fix Fix utils.get_argument_sources() when kwargs is given as <code>**kwargs</code>.</li> </ul>"},{"location":"CHANGELOG/#v070","title":"v0.7.0","text":"<ul> <li><code>ImproperUseError</code> is now independent of <code>VarnameRetrievingError</code></li> <li>Deprecate <code>argname</code>, superseded by <code>argname2</code></li> </ul> <pre><code>  &gt;&gt;&gt; argname(a, b, ...) # before\n  &gt;&gt;&gt; argname2('a', 'b', ...) # after\n</code></pre> <ul> <li>Add <code>dispatch</code> argument to <code>argname</code>/<code>argment2</code> to be used for single-dispatched functions.</li> </ul>"},{"location":"CHANGELOG/#v065","title":"v0.6.5","text":"<ul> <li>Add <code>sep</code> argument to <code>helpers.debug()</code></li> </ul>"},{"location":"CHANGELOG/#v064","title":"v0.6.4","text":"<ul> <li>Add ImproperUseError to distinguish node retrieving error from improper varname use #49</li> </ul>"},{"location":"CHANGELOG/#v063","title":"v0.6.3","text":"<ul> <li>Fix standard library ignoring ignores 3rd-party libraries under site-packages/</li> <li>Allow pathlib.Path object to be used in ignore items</li> </ul>"},{"location":"CHANGELOG/#v062","title":"v0.6.2","text":"<ul> <li>Remove argument <code>full</code> for <code>nameof</code>, use <code>vars_only</code> instead. When <code>vars_only=False</code>, source of the argument returned.</li> </ul> <pre><code># before:\nnameof(a.b, full=True) # 'a.b'\nnameof(x[0], full=True) # unable to fetch\n# after (requires asttoken):\nnameof(a.b, vars_only=False) # 'a.b'\nnameof(x[0], vars_only=False) # 'x[0]'\n</code></pre> <ul> <li>Add argument <code>frame</code> to <code>argname</code>, so that it can be wrapped.</li> </ul> <pre><code>def argname2(arg, *more_args):\n    return argname(arg, *more_args, frame=2)\n</code></pre> <ul> <li>Allow <code>argname</code> to fetch the source of variable keyword arguments (<code>**kwargs</code>), which will be an empty dict (<code>{}</code>) when no keyword arguments passed.</li> </ul> <pre><code>def func(a, **kwargs):\n    return argname(a, kwargs)\n# before:\nfunc(x) # raises error\n# after:\nfunc(x) # returns ('x', {})\n</code></pre> <ul> <li>Add argument <code>pos_only</code> to <code>argname</code> to only match the positional arguments</li> </ul> <pre><code># before\ndef func(a, b=1):\n  return argname(a)\nfunc(x) # 'x'\nfunc(x, b=2) # error since 2 is not ast.Name\n\n# after\ndef func(a, b=1):\n  return argname(a, pos_only=True)\nfunc(x) # 'x'\nfunc(x, b=2) # 'x'\n</code></pre> <ul> <li>Parse the arguments only if needed</li> </ul> <pre><code># before\ndef func(a, b):\n  return argname(a)\nfunc(x, 1) # NonVariableArgumentError\n\n# after\nfunc(x, 1) # 'x'\n</code></pre> <ul> <li>Allow variable positional arguments for <code>argname</code> so that <code>argname(*args)</code> is allowed</li> </ul> <pre><code># before\ndef func(arg, *args):\n  return argname(arg, args) # *args not allowed\nx = y = 1\nfunc(x, y) # ('x', ('y', 1))\n\n# after\ndef func(arg, *args):\n  return argname(arg, *args)\nx = y = 1\nfunc(x, y) # ('x', 'y')\n</code></pre> <ul> <li>Add <code>vars_only</code> (defaults to <code>False</code>) argument to <code>helpers.debug</code> so source of expression becomes available</li> </ul> <pre><code>a=1\ndebug(a+a) # DEBUG: a+a=2\n</code></pre>"},{"location":"CHANGELOG/#v061","title":"v0.6.1","text":"<ul> <li>Add <code>argname</code> to retrieve argument names/sources passed to a function</li> </ul>"},{"location":"CHANGELOG/#v060","title":"v0.6.0","text":"<ul> <li>Changed:</li> <li><code>Wrapper</code>, <code>register</code> and <code>debug</code> moved to <code>varname.helpers</code></li> <li>Argument <code>caller</code> changed to <code>frame</code> across all APIs</li> <li><code>ignore</code> accepting module, filename, function, (function, num_decorators), (module, qualname) and (filename, qualname)</li> <li>Removed:</li> <li><code>inject</code> (Use <code>helpers.regiester</code> instead)</li> <li><code>inject_varname</code> (Use <code>helpers.regiester</code> instead)</li> <li><code>namedtuple</code></li> <li>Added:</li> <li>Arguments <code>frame</code> and <code>ignore</code> to <code>Wrapper</code></li> <li><code>helpers.register</code> as a decorator for functions</li> </ul>"},{"location":"CHANGELOG/#v056","title":"v0.5.6","text":"<ul> <li>Add <code>ignore</code> argument to <code>varname</code> to ignore frames that are not counted by caller</li> <li>Deprecate <code>inject_varname</code>, use <code>register</code> instead</li> </ul>"},{"location":"CHANGELOG/#v055","title":"v0.5.5","text":"<ul> <li>Deprecate inject and use inject_varname decorator instead</li> </ul>"},{"location":"CHANGELOG/#v054","title":"v0.5.4","text":"<ul> <li>Allow <code>varname.varname</code> to receive multiple variables on the left-hand side</li> </ul>"},{"location":"CHANGELOG/#v053","title":"v0.5.3","text":"<ul> <li>Add <code>debug</code> function</li> <li>Deprecate <code>namedtuple</code> (will be removed in <code>0.6.0</code>)</li> </ul>"},{"location":"CHANGELOG/#v052","title":"v0.5.2","text":"<ul> <li>Move messaging of weird nameof calls from <code>_bytecode_nameof</code> to <code>nameof</code>.</li> <li>Disallow <code>full</code> to be used when <code>_bytecode_nameof</code> needs to be invoked.</li> </ul>"},{"location":"CHANGELOG/#v051","title":"v0.5.1","text":"<ul> <li>Add better messaging for weird nameof calls</li> </ul>"},{"location":"CHANGELOG/#v050","title":"v0.5.0","text":"<ul> <li>Allow <code>nameof</code> to retrieve full name of chained attribute calls</li> <li>Add <code>__all__</code> to the module so that only desired APIs are exposed when <code>from varname import *</code></li> <li>Give more hints on <code>nameof</code> being called in a weird way when no soucecode available.</li> </ul>"},{"location":"CHANGELOG/#v040","title":"v0.4.0","text":"<ul> <li>Change default of <code>raise_exc</code> to <code>True</code> for all related APIs</li> <li>Deprecate <code>var_0</code></li> <li>Get rid of <code>VarnameRetrievingWarning</code>.</li> </ul>"},{"location":"CHANGELOG/#v030","title":"v0.3.0","text":"<ul> <li>Use sys._getframe instead of inspect.stack for efficiency (#9)</li> <li>Add alternative way of testing bytecode nameof (#10)</li> <li>Drop support for pytest, don't try to find node when executing fails</li> <li>Remodel <code>will</code> for better logic</li> <li>Support attributes in varname and nameof (#14)</li> </ul>"},{"location":"CHANGELOG/#v020","title":"v0.2.0","text":"<ul> <li>Fix #5 and fit nameof in more cases</li> </ul>"},{"location":"CHANGELOG/#v017","title":"v0.1.7","text":"<ul> <li>Add <code>inject</code> function</li> </ul>"},{"location":"CHANGELOG/#v016","title":"v0.1.6","text":"<ul> <li>Fit situations when frames cannot be fetched</li> <li>Add shortcut for <code>namedtuple</code></li> </ul>"},{"location":"CHANGELOG/#v015","title":"v0.1.5","text":"<ul> <li>Fix <code>will</code> from a property call</li> </ul>"},{"location":"CHANGELOG/#v014","title":"v0.1.4","text":"<ul> <li>Add <code>will</code> to detect next immediate attribute name</li> </ul>"},{"location":"CHANGELOG/#v013","title":"v0.1.3","text":"<ul> <li>Add arugment <code>raise_exc</code> for <code>varname</code> to raise an exception instead of returning <code>var_&lt;index&gt;</code></li> </ul>"},{"location":"CHANGELOG/#v012","title":"v0.1.2","text":"<ul> <li>Add function <code>nameof</code></li> </ul>"},{"location":"CHANGELOG/#v011","title":"v0.1.1","text":"<ul> <li>Add a value wrapper <code>Wrapper</code> class</li> </ul>"},{"location":"CHANGELOG/#v010","title":"v0.1.0","text":"<ul> <li>Implement <code>varname</code> function</li> </ul>"},{"location":"api/varname.core/","title":"varname.core","text":"module &lt;/&gt; <p>Provide core features for varname</p> Functions <ul> <li><code>argname</code><code>(</code><code>arg</code>, <code>*more_args</code>, <code>func</code>, <code>dispatch</code>, <code>frame</code>, <code>ignore</code>, <code>vars_only</code><code>)</code> (Union) \u2014 Get the names/sources of arguments passed to a function.&lt;/&gt;</li> <li><code>nameof</code><code>(</code><code>var</code>, <code>*more_vars</code>, <code>frame</code>, <code>vars_only</code><code>)</code> (Union) \u2014 Get the names of the variables passed in&lt;/&gt;</li> <li><code>varname</code><code>(</code><code>frame</code>, <code>ignore</code>, <code>multi_vars</code>, <code>raise_exc</code>, <code>strict</code><code>)</code> (Union) \u2014 Get the name of the variable(s) that assigned by function call orclass instantiation. &lt;/&gt;</li> <li><code>will</code><code>(</code><code>frame</code>, <code>raise_exc</code><code>)</code> (str) \u2014 Detect the attribute name right immediately after a function call.&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Get the name of the variable(s) that assigned by function call orclass instantiation.</p> <p>To debug and specify the right frame and ignore arguments, you can set debug on and see how the frames are ignored or selected:</p> <pre><code>&gt;&gt;&gt; from varname import config\n&gt;&gt;&gt; config.debug = True\n</code></pre> Parameters <ul> <li><code>frame</code> (int, optional) \u2014 <code>N</code>th frame used to retrieve the variable name. This means<code>N-1</code> intermediate frames will be skipped. Note that the frames match <code>ignore</code> will not be counted. See <code>ignore</code> for details. </li> <li><code>ignore</code> (Union, optional) \u2014 Frames to be ignored in order to reach the <code>N</code>th frame.These frames will not be counted to skip within that <code>N-1</code> frames. You can specify: <ul><li>- A module (or filename of a module). Any calls from it and its\u00a0    submodules will be ignored.</li><li>- A function. If it looks like it might be a decorated function,\u00a0    a <code>MaybeDecoratedFunctionWarning</code> will be shown.</li><li>- Tuple of a function and a number of additional frames that should\u00a0    be skipped just before reaching this function in the stack.\u00a0    This is typically used for functions that have been decorated\u00a0    with a 'classic' decorator that replaces the function with\u00a0    a wrapper. In that case each such decorator involved should\u00a0    be counted in the number that's the second element of the tuple.</li><li>- Tuple of a module (or filename) and qualified name (qualname).\u00a0    You can use Unix shell-style wildcards to match the qualname.\u00a0    Otherwise the qualname must appear exactly once in the\u00a0    module/file.</li></ul>By default, all calls from <code>varname</code> package, python standardlibraries and lambda functions are ignored. </li> <li><code>multi_vars</code> (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS).If <code>True</code>, this function returns a tuple of the variable names, even there is only one variable on LHS. If <code>False</code>, and multiple variables on LHS, a <code>ImproperUseError</code> will be raised. </li> <li><code>raise_exc</code> (bool, optional) \u2014 Whether we should raise an exception if failedto retrieve the ast node. Note that set this to <code>False</code> will NOT supress the exception when the use of <code>varname</code> is improper (i.e. multiple variables on LHS with <code>multi_vars</code> is <code>False</code>). See <code>Raises/ImproperUseError</code>. </li> <li><code>strict</code> (bool, optional) \u2014 Whether to only return the variable name(s) if the result ofthe call is assigned to it/them directly. For example, <code>a = func()</code> rather than <code>a = [func()]</code> </li> </ul> Returns (Union) <p>The variable name, or <code>None</code> when <code>raise_exc</code> is <code>False</code> and    we failed to retrieve the ast node for the variable(s). A tuple or a hierarchy (tuple of tuples) of variable names     when <code>multi_vars</code> is <code>True</code>.</p> Raises <ul> <li><code>ImproperUseError</code> \u2014 When the use of <code>varname()</code> is improper, including:<ul><li>- When LHS is not an <code>ast.Name</code> or <code>ast.Attribute</code> node or not a\u00a0    list/tuple of them</li><li>- When there are multiple variables on LHS but <code>multi_vars</code> is False</li><li>- When <code>strict</code> is True, but the result is not assigned to\u00a0    variable(s) directly</li></ul>Note that <code>raise_exc=False</code> will NOT suppress this exception.</li> <li><code>MultiTargetAssignmentWarning</code> \u2014 When there are multiple targetin the assign node. (e.g: <code>a = b = func()</code>, in such a case, <code>a == 'b'</code>, may not be the case you want) </li> <li><code>VarnameRetrievingError</code> \u2014 When we are unable to retrieve the ast nodefor the variable(s) and <code>raise_exc</code> is set to <code>True</code>. </li> </ul> function &lt;/&gt; <p>Detect the attribute name right immediately after a function call.</p> Examples <pre><code>&gt;&gt;&gt; class AwesomeClass:&gt;&gt;&gt;     def __init__(self):\n&gt;&gt;&gt;         self.will = None\n</code></pre> <pre><code>&gt;&gt;&gt;     def permit(self):\n&gt;&gt;&gt;         self.will = will()\n&gt;&gt;&gt;         if self.will == 'do':\n&gt;&gt;&gt;             # let self handle do\n&gt;&gt;&gt;             return self\n&gt;&gt;&gt;         raise AttributeError(\n&gt;&gt;&gt;             'Should do something with AwesomeClass object'\n&gt;&gt;&gt;         )\n</code></pre> <pre><code>&gt;&gt;&gt;     def do(self):\n&gt;&gt;&gt;         if self.will != 'do':\n&gt;&gt;&gt;             raise AttributeError(\"You don't have permission to do\")\n&gt;&gt;&gt;         return 'I am doing!'\n</code></pre> <pre><code>&gt;&gt;&gt; awesome = AwesomeClass()\n&gt;&gt;&gt; # AttributeError: You don't have permission to do\n&gt;&gt;&gt; awesome.do()\n&gt;&gt;&gt; # AttributeError: Should do something with AwesomeClass object\n&gt;&gt;&gt; awesome.permit()\n&gt;&gt;&gt; awesome.permit().do() == 'I am doing!'\n</code></pre> Parameters <ul> <li><code>frame</code> (int, optional) \u2014 At which frame this function is called.</li> <li><code>raise_exc</code> (bool, optional) \u2014 Raise exception we failed to detect the ast nodeThis will NOT supress the <code>ImproperUseError</code> </li> </ul> Returns (str) <p>The attribute name right after the function call.<code>None</code> if ast node cannot be retrieved and <code>raise_exc</code> is <code>False</code></p> Raises <ul> <li><code>ImproperUseError</code> \u2014 When (the wraper of) this function is not calledinside a method/property of a class instance. Note that this exception will not be suppressed by <code>raise_exc=False</code> </li> <li><code>VarnameRetrievingError</code> \u2014 When <code>raise_exc</code> is <code>True</code> and we failed todetect the attribute name (including not having one) </li> </ul> function &lt;/&gt; <p>Get the names of the variables passed in</p> Examples <pre><code>&gt;&gt;&gt; a = 1&gt;&gt;&gt; nameof(a) # 'a'\n</code></pre> <pre><code>&gt;&gt;&gt; b = 2\n&gt;&gt;&gt; nameof(a, b) # ('a', 'b')\n</code></pre> <pre><code>&gt;&gt;&gt; x = lambda: None\n&gt;&gt;&gt; x.y = 1\n&gt;&gt;&gt; nameof(x.y, vars_only=False) # 'x.y'\n</code></pre> <p>Note</p> <p>This function works with the environments where source code is available, in other words, the callee's node can be retrieved by <code>executing</code>. In some cases, for example, running code from python shell/REPL or from <code>exec</code>/<code>eval</code>, we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases.</p> Parameters <ul> <li><code>var</code> (Any) \u2014 The variable to retrieve the name of</li> <li><code>*more_vars</code> (Any) \u2014 Other variables to retrieve the names of</li> <li><code>frame</code> (int, optional) \u2014 The this function is called from the wrapper of it. <code>frame=1</code>means no wrappers. Note that the calls from standard libraries are ignored. Also note that the wrapper has to have signature as this one. </li> <li><code>vars_only</code> (bool, optional) \u2014 Whether only allow variables/attributes as arguments orany expressions. If <code>False</code>, then the sources of the arguments will be returned. </li> </ul> Returns (Union) <p>The names/sources of variables/expressions passed in.    If a single argument is passed, return the name/source of it.     If multiple variables are passed, return a tuple of their     names/sources.     If the argument is an attribute (e.g. <code>a.b</code>) and <code>vars_only</code> is     <code>True</code>, only <code>\"b\"</code> will returned. Set <code>vars_only</code> to <code>False</code> to     get <code>\"a.b\"</code>.</p> Raises <ul> <li><code>VarnameRetrievingError</code> \u2014 When the callee's node cannot be retrieved ortrying to retrieve the full name of non attribute series calls. </li> </ul> function &lt;/&gt; <p>Get the names/sources of arguments passed to a function.</p><p>Instead of passing the argument variables themselves to this function (like <code>argname()</code> does), you should pass their names instead.</p> Parameters <ul> <li><code>arg</code> (str) \u2014 and</li> <li><code>*more_args</code> (str) \u2014 The names of the arguments that you want to retrievenames/sources of. You can also use subscripts to get parts of the results.  def func(args, *kwargs):     return argname('args[0]', 'kwargs[x]') # no quote needed  Star argument is also allowed:  def func(args, x = 1):     return argname('args', 'x') a = b = c = 1 func(a, b, x=c) # ('a', 'b', 'c')  Note the difference:  def func(*args, x = 1):     return argname('args', 'x') a = b = c = 1 func(a, b, x=c) # (('a', 'b'), 'c') </li> <li><code>func</code> (Callable, optional) \u2014 The target function. If not provided, the AST node of thefunction call will be used to fetch the function: <ul><li>- If a variable (ast.Name) used as function, the <code>node.id</code> will\u00a0    be used to get the function from <code>locals()</code> or <code>globals()</code>.</li><li>- If variable (ast.Name), attributes (ast.Attribute),\u00a0    subscripts (ast.Subscript), and combinations of those and\u00a0    literals used as function, <code>pure_eval</code> will be used to evaluate\u00a0    the node</li><li>- If <code>pure_eval</code> is not installed or failed to evaluate, <code>eval</code>\u00a0    will be used. A warning will be shown since unwanted side\u00a0    effects may happen in this case.</li></ul>You are very encouraged to always pass the function explicitly.</li> <li><code>dispatch</code> (Type, optional) \u2014 If a function is a single-dispatched function, you canspecify a type for it to dispatch the real function. If this is specified, expect <code>func</code> to be the generic function if provided. </li> <li><code>frame</code> (int, optional) \u2014 The frame where target function is called from this call.Calls from python standard libraries are ignored. </li> <li><code>ignore</code> (Union, optional) \u2014 The intermediate calls to be ignored. See <code>varname.ignore</code></li> <li><code>vars_only</code> (bool, optional) \u2014 Require the arguments to be variables only.If False, <code>asttokens</code> is required to retrieve the source. </li> </ul> Returns (Union) <p>The argument source when no more_args passed, otherwise a tuple ofargument sources Note that when an argument is an <code>ast.Constant</code>, <code>repr(arg.value)</code> is returned, so <code>argname()</code> return <code>'a'</code> for <code>func(\"a\")</code></p> Raises <ul> <li><code>ImproperUseError</code> \u2014 When frame or func is incorrectly specified.</li> <li><code>VarnameRetrievingError</code> \u2014 When the ast node where the function is calledcannot be retrieved </li> </ul>"},{"location":"api/varname.core/#varnamecore","title":"varname.core","text":""},{"location":"api/varname.core/#varnamecorevarname","title":"<code>varname.core.</code><code>varname</code><code>(</code><code>frame=1</code>, <code>ignore=None</code>, <code>multi_vars=False</code>, <code>raise_exc=True</code>, <code>strict=True</code><code>)</code>","text":""},{"location":"api/varname.core/#varnamecorewill","title":"<code>varname.core.</code><code>will</code><code>(</code><code>frame=1</code>, <code>raise_exc=True</code><code>)</code>","text":""},{"location":"api/varname.core/#varnamecorenameof","title":"<code>varname.core.</code><code>nameof</code><code>(</code><code>var</code>, <code>*more_vars</code>, <code>frame=1</code>, <code>vars_only=True</code><code>)</code>","text":""},{"location":"api/varname.core/#varnamecoreargname","title":"<code>varname.core.</code><code>argname</code><code>(</code><code>arg</code>, <code>*more_args</code>, <code>func=None</code>, <code>dispatch=None</code>, <code>frame=1</code>, <code>ignore=None</code>, <code>vars_only=True</code><code>)</code>","text":""},{"location":"api/varname.helpers/","title":"varname.helpers","text":"module &lt;/&gt; <p>Some helper functions builtin based upon core features</p> Classes <ul> <li><code>Wrapper</code> \u2014 A wrapper with ability to retrieve the variable name&lt;/&gt;</li> </ul> Functions <ul> <li><code>debug</code><code>(</code><code>var</code>, <code>*more_vars</code>, <code>prefix</code>, <code>merge</code>, <code>repr</code>, <code>sep</code>, <code>vars_only</code><code>)</code> \u2014 Print variable names and values.&lt;/&gt;</li> <li><code>exec_code</code><code>(</code><code>code</code>, <code>globals</code>, <code>locals</code>, <code>sourcefile</code>, <code>frame</code>, <code>ignore</code>, <code>**kwargs</code><code>)</code> \u2014 Execute code where source code is visible at runtime.&lt;/&gt;</li> <li><code>jsobj</code><code>(</code><code>*args</code>, <code>vars_only</code>, <code>frame</code>, <code>**kwargs</code><code>)</code> (Dict) \u2014 A wrapper to create a JavaScript-like object&lt;/&gt;</li> <li><code>register</code><code>(</code><code>cls_or_func</code>, <code>frame</code>, <code>ignore</code>, <code>multi_vars</code>, <code>raise_exc</code>, <code>strict</code><code>)</code> (Union) \u2014 A decorator to register varname to a class or function&lt;/&gt;</li> </ul> function &lt;/&gt; <p>A decorator to register varname to a class or function</p><p>When registered to a class, it can be accessed by <code>self.__varname__</code>; while to a function, it is registered to globals, meaning that it can be accessed directly.</p> Parameters <ul> <li><code>frame</code> (int, optional) \u2014 The call stack index, indicating where this classis instantiated relative to where the variable is finally retrieved </li> <li><code>multi_vars</code> (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS).If <code>True</code>, this function returns a tuple of the variable names, even there is only one variable on LHS. If <code>False</code>, and multiple variables on LHS, a <code>VarnameRetrievingError</code> will be raised. </li> <li><code>raise_exc</code> (bool, optional) \u2014 Whether we should raise an exception if failedto retrieve the name. </li> <li><code>strict</code> (bool, optional) \u2014 Whether to only return the variable name if the result ofthe call is assigned to it directly. </li> </ul> Examples <pre><code>&gt;&gt;&gt; @varname.register&gt;&gt;&gt; class Foo: pass\n&gt;&gt;&gt; foo = Foo()\n&gt;&gt;&gt; # foo.__varname__ == 'foo'\n&gt;&gt;&gt;\n&gt;&gt;&gt; @varname.register\n&gt;&gt;&gt; def func():\n&gt;&gt;&gt;   return __varname__\n&gt;&gt;&gt; foo = func() # foo == 'foo'\n</code></pre> Returns (Union) <p>The wrapper function or the class/function itselfif it is specified explictly.</p> class &lt;/&gt; <p>A wrapper with ability to retrieve the variable name</p> Examples <pre><code>&gt;&gt;&gt; foo = Wrapper(True)&gt;&gt;&gt; # foo.name == 'foo'\n&gt;&gt;&gt; # foo.value == True\n</code></pre> <pre><code>&gt;&gt;&gt; val = {}\n&gt;&gt;&gt; bar = Wrapper(val)\n&gt;&gt;&gt; # bar.name == 'bar'\n&gt;&gt;&gt; # bar.value is val\n</code></pre> Parameters <ul> <li><code>value</code> (Any) \u2014 The value to be wrapped</li> <li><code>raise_exc</code> (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve</li> <li><code>strict</code> (bool, optional) \u2014 Whether to only return the variable name if the wrapper isassigned to it directly. </li> </ul> Attributes <ul> <li><code>name</code> \u2014 The variable name to which the instance is assigned</li> <li><code>value</code> \u2014 The value this wrapper wraps</li> </ul> function &lt;/&gt; <p>A wrapper to create a JavaScript-like object</p><p>When an argument is passed as positional argument, the name of the variable will be used as the key, while the value will be used as the value.</p> Examples <pre><code>&gt;&gt;&gt; obj = jsobj(a=1, b=2)&gt;&gt;&gt; # obj == {'a': 1, 'b': 2}\n&gt;&gt;&gt; # obj.a == 1\n&gt;&gt;&gt; # obj.b == 2\n&gt;&gt;&gt; a = 1\n&gt;&gt;&gt; b = 2\n&gt;&gt;&gt; obj = jsobj(a, b, c=3)\n&gt;&gt;&gt; # obj == {'a': 1, 'b': 2, 'c': 3}\n</code></pre> Parameters <ul> <li><code>*args</code> (Any) \u2014 The positional arguments</li> <li><code>vars_only</code> (bool, optional) \u2014 Whether to only include variables in the output</li> <li><code>frame</code> (int, optional) \u2014 The call stack index. You can understand this as the number ofwrappers around this function - 1. </li> <li><code>**kwargs</code> (Any) \u2014 The keyword arguments</li> </ul> Returns (Dict) <p>A dict-like object</p> function &lt;/&gt; <p>Print variable names and values.</p> Examples <pre><code>&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = object\n&gt;&gt;&gt; print(f'a={a}') # previously, we have to do\n&gt;&gt;&gt; print(f'{a=}')  # or with python3.8\n&gt;&gt;&gt; # instead we can do:\n&gt;&gt;&gt; debug(a) # DEBUG: a=1\n&gt;&gt;&gt; debug(a, prefix='') # a=1\n&gt;&gt;&gt; debug(a, b, merge=True) # a=1, b=&lt;object object at 0x2b9a4c89cf00&gt;\n</code></pre> Parameters <ul> <li><code>var</code> \u2014 The variable to print</li> <li><code>*more_vars</code> \u2014 Other variables to print</li> <li><code>prefix</code> (str, optional) \u2014 A prefix to print for each line</li> <li><code>merge</code> (bool, optional) \u2014 Whether merge all variables in one line or not</li> <li><code>repr</code> (bool, optional) \u2014 Print the value as <code>repr(var)</code>? otherwise <code>str(var)</code></li> <li><code>sep</code> (str, optional) \u2014 The separator between the variable name and value</li> </ul> function &lt;/&gt; <p>Execute code where source code is visible at runtime.</p><p>This function is useful when you want to execute some code, where you want to retrieve the AST node of the code at runtime. This function will create a temporary file and write the code into it, then execute the code in the file.</p> Examples <pre><code>&gt;&gt;&gt; from varname import varname&gt;&gt;&gt; def func(): return varname()\n&gt;&gt;&gt; exec('var = func()')  # VarnameRetrievingError:\n&gt;&gt;&gt;                       #  Unable to retrieve the ast node.\n&gt;&gt;&gt; from varname.helpers import code_exec\n&gt;&gt;&gt; code_exec('var = func()')  # var == 'var'\n</code></pre> Parameters <ul> <li><code>code</code> (str) \u2014 The code to execute.</li> <li><code>globals</code> (Dict, optional) \u2014 The globals to use.</li> <li><code>locals</code> (Dict, optional) \u2014 The locals to use.</li> <li><code>sourcefile</code> (os.pathlike | str, optional) \u2014 The source file to write the code into.if not given, a temporary file will be used. This file will be deleted after the code is executed. </li> <li><code>frame</code> (int, optional) \u2014 The call stack index. You can understand this as the number ofwrappers around this function. This is used to fetch <code>globals</code> and <code>locals</code> from where the destination function (include the wrappers of this function) is called. </li> <li><code>ignore</code> (Union, optional) \u2014 The intermediate calls to be ignored. See <code>varname.ignore</code>Note that if both <code>globals</code> and <code>locals</code> are given, <code>frame</code> and <code>ignore</code> will be ignored. </li> <li><code>**kwargs</code> (Any) \u2014 The keyword arguments to pass to <code>exec</code>.</li> </ul>"},{"location":"api/varname.helpers/#varnamehelpers","title":"varname.helpers","text":""},{"location":"api/varname.helpers/#varnamehelpersregister","title":"<code>varname.helpers.</code><code>register</code><code>(</code><code>cls_or_func=None</code>, <code>frame=1</code>, <code>ignore=None</code>, <code>multi_vars=False</code>, <code>raise_exc=True</code>, <code>strict=True</code><code>)</code>","text":""},{"location":"api/varname.helpers/#varnamehelperswrapper","title":"<code>varname.helpers.</code><code>Wrapper</code><code>(</code><code>value</code>, <code>frame=1</code>, <code>ignore=None</code>, <code>raise_exc=True</code>, <code>strict=True</code><code>)</code>","text":""},{"location":"api/varname.helpers/#varnamehelpersjsobj","title":"<code>varname.helpers.</code><code>jsobj</code><code>(</code><code>*args</code>, <code>vars_only=True</code>, <code>frame=1</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/varname.helpers/#varnamehelpersdebug","title":"<code>varname.helpers.</code><code>debug</code><code>(</code><code>var</code>, <code>*more_vars</code>, <code>prefix='DEBUG: '</code>, <code>merge=False</code>, <code>repr=True</code>, <code>sep='='</code>, <code>vars_only=False</code><code>)</code>","text":""},{"location":"api/varname.helpers/#varnamehelpersexec_code","title":"<code>varname.helpers.</code><code>exec_code</code><code>(</code><code>code</code>, <code>globals=None</code>, <code>locals=None</code>, <code>sourcefile=None</code>, <code>frame=1</code>, <code>ignore=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/varname.ignore/","title":"varname.ignore","text":"module &lt;/&gt; <p>The frame ignoring system for varname</p><p>There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame.</p> <ol> <li>Ignore frames by a given module. Any calls inside it and inside its    submodules will be ignored. A filename (path) to a module is also acceptable    and recommended when code is executed by <code>exec</code> without module available.</li> <li>Ignore frames by a given pair of module and a qualified name (qualname).    See 1) for acceptable modules. The qualname should be unique in that module.</li> <li>Ignore frames by a (non-decorated) function.</li> <li>Ignore frames by a decorated function. In this case, you can specified a    tuple with the function and the number of decorators of it. The decorators    on the wrapper function inside the decorators should also be counted.</li> </ol> <p>Any frames in <code>varname</code>, standard libraries, and frames of any expressions like  are ignored by default. Classes <ul> <li><code>IgnoreElem</code><code>(</code><code>)</code> \u2014 An element of the ignore list&lt;/&gt;</li> <li><code>IgnoreModule</code> \u2014 Ignore calls from a module or its submodules&lt;/&gt;</li> <li><code>IgnoreFilename</code> \u2014 Ignore calls from a module by matching its filename&lt;/&gt;</li> <li><code>IgnoreDirname</code> \u2014 Ignore calls from modules inside a directory&lt;/&gt;</li> <li><code>IgnoreStdlib</code> \u2014 Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True)&lt;/&gt;</li> <li><code>IgnoreFunction</code> \u2014 Ignore a non-decorated function&lt;/&gt;</li> <li><code>IgnoreDecorated</code> \u2014 Ignore a decorated function&lt;/&gt;</li> <li><code>IgnoreModuleQualname</code> \u2014 Ignore calls by qualified name in the module&lt;/&gt;</li> <li><code>IgnoreFilenameQualname</code> \u2014 Ignore calls with given qualname in the module with the filename&lt;/&gt;</li> <li><code>IgnoreOnlyQualname</code> \u2014 Ignore calls that match the given qualname, across all frames.&lt;/&gt;</li> <li><code>IgnoreList</code> \u2014 The ignore list to match the frames to see if they should be ignored&lt;/&gt;</li> </ul> Functions <ul> <li><code>create_ignore_elem</code><code>(</code><code>ignore_elem</code><code>)</code> (IgnoreElem) \u2014 Create an ignore element according to the type&lt;/&gt;</li> </ul> abstract class &lt;/&gt; <p>An element of the ignore list</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> abstract method &lt;/&gt; <p>Whether the frame matches the ignore element</p> method &lt;/&gt; <p>Representation of the element</p> class &lt;/&gt; Bases varname.ignore.IgnoreElem <p>Ignore calls from a module or its submodules</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> class &lt;/&gt; Bases varname.ignore.IgnoreElem <p>Ignore calls from a module by matching its filename</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> class &lt;/&gt; Bases varname.ignore.IgnoreElem <p>Ignore calls from modules inside a directory</p><p>Currently used internally to ignore calls from standard libraries.</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> class &lt;/&gt; Bases varname.ignore.IgnoreDirname varname.ignore.IgnoreElem <p>Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True)</p><p>But we need to ignore 3rd-party packages under site-packages/.</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> class &lt;/&gt; Bases varname.ignore.IgnoreElem <p>Ignore a non-decorated function</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> class &lt;/&gt; Bases varname.ignore.IgnoreElem <p>Ignore a decorated function</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> class &lt;/&gt; Bases varname.ignore.IgnoreElem <p>Ignore calls by qualified name in the module</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> class &lt;/&gt; Bases varname.ignore.IgnoreElem <p>Ignore calls with given qualname in the module with the filename</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> class &lt;/&gt; Bases varname.ignore.IgnoreElem <p>Ignore calls that match the given qualname, across all frames.</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code> \u2014 Define different attributes for subclasses&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Representation of the element&lt;/&gt;</li> <li><code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (bool) \u2014 Whether the frame matches the ignore element&lt;/&gt;</li> <li><code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code> \u2014 init function for subclasses&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Define different attributes for subclasses</p> method &lt;/&gt; <p>init function for subclasses</p> method &lt;/&gt; <p>Representation of the element</p> method &lt;/&gt; <p>Whether the frame matches the ignore element</p> function &lt;/&gt; <p>Create an ignore element according to the type</p> class &lt;/&gt; <p>The ignore list to match the frames to see if they should be ignored</p> Methods <ul> <li><code>create</code><code>(</code><code>ignore</code>, <code>ignore_lambda</code>, <code>ignore_varname</code><code>)</code> (IgnoreList) \u2014 Create an IgnoreList object&lt;/&gt;</li> <li><code>get_frame</code><code>(</code><code>frame_no</code><code>)</code> (frame) \u2014 Get the right frame by the frame number&lt;/&gt;</li> <li><code>nextframe_to_check</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> (int) \u2014 Find the next frame to check&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Create an IgnoreList object</p> Parameters <ul> <li><code>ignore</code> (Union, optional) \u2014 An element of the ignore list, eitherA module (or filename of a module) A tuple of module (or filename) and qualified name A function A tuple of function and number of decorators </li> <li><code>ignore_lambda</code> (bool, optional) \u2014 whether ignore lambda functions</li> <li><code>ignore_varname</code> (bool, optional) \u2014 whether the calls from this package</li> </ul> Returns (IgnoreList) <p>The IgnoreList object</p> method &lt;/&gt; <p>Find the next frame to check</p><p>In modst cases, the next frame to check is the next adjacent frame. But for IgnoreDecorated, the next frame to check should be the next <code>ignore[1]</code>th frame.</p> Parameters <ul> <li><code>frame_no</code> (int) \u2014 The index of current frame to check</li> <li><code>frameinfos</code> (List) \u2014 The frame info objects</li> </ul> Returns (int) <p>A number for Next <code>N</code>th frame to check. 0 if no frame matched.</p> method &lt;/&gt; <p>Get the right frame by the frame number</p> Parameters <ul> <li><code>frame_no</code> (int) \u2014 The index of the frame to get</li> </ul> Returns (frame) <p>The desired frame</p> Raises <ul> <li><code>VarnameRetrievingError</code> \u2014 if any exceptions raised during the process.</li> </ul>"},{"location":"api/varname.ignore/#varnameignore","title":"varname.ignore","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelem","title":"<code>varname.ignore.</code><code>IgnoreElem</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemmatch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignoremodule","title":"<code>varname.ignore.</code><code>IgnoreModule</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_1","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_1","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignoremodulematch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignorefilename","title":"<code>varname.ignore.</code><code>IgnoreFilename</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_2","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_1","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_2","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignorefilenamematch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignoredirname","title":"<code>varname.ignore.</code><code>IgnoreDirname</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_3","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_2","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_3","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignoredirnamematch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignorestdlib","title":"<code>varname.ignore.</code><code>IgnoreStdlib</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_4","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_3","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_4","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignorestdlibmatch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignorefunction","title":"<code>varname.ignore.</code><code>IgnoreFunction</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_5","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_4","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_5","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignorefunctionmatch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignoredecorated","title":"<code>varname.ignore.</code><code>IgnoreDecorated</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_6","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_5","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_6","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignoredecoratedmatch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignoremodulequalname","title":"<code>varname.ignore.</code><code>IgnoreModuleQualname</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_7","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_6","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_7","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignoremodulequalnamematch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignorefilenamequalname","title":"<code>varname.ignore.</code><code>IgnoreFilenameQualname</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_8","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_7","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_8","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignorefilenamequalnamematch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignoreignoreonlyqualname","title":"<code>varname.ignore.</code><code>IgnoreOnlyQualname</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_9","title":"<code>__init_subclass__</code><code>(</code><code>attrs</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_8","title":"<code>subclass_init</code><code>(</code><code>*ign_args</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_9","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.ignore/#varnameignoreignoreonlyqualnamematch","title":"<code>match</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.ignore/#varnameignorecreate_ignore_elem","title":"<code>varname.ignore.</code><code>create_ignore_elem</code><code>(</code><code>ignore_elem</code><code>)</code> \u2192 IgnoreElem","text":""},{"location":"api/varname.ignore/#varnameignoreignorelist","title":"<code>varname.ignore.</code><code>IgnoreList</code><code>(</code><code>ignore_list</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignorelistcreate","title":"<code>create</code><code>(</code><code>ignore=None</code>, <code>ignore_lambda=True</code>, <code>ignore_varname=True</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignorelistnextframe_to_check","title":"<code>nextframe_to_check</code><code>(</code><code>frame_no</code>, <code>frameinfos</code><code>)</code>","text":""},{"location":"api/varname.ignore/#varnameignoreignorelistget_frame","title":"<code>get_frame</code><code>(</code><code>frame_no</code><code>)</code>","text":""},{"location":"api/varname/","title":"varname","text":"package &lt;/&gt; <p>Dark magics about variable names in python</p> module &lt;/&gt; <p>Provide core features for varname</p> Functions <ul> <li><code>argname</code><code>(</code><code>arg</code>, <code>*more_args</code>, <code>func</code>, <code>dispatch</code>, <code>frame</code>, <code>ignore</code>, <code>vars_only</code><code>)</code> (Union) \u2014 Get the names/sources of arguments passed to a function.&lt;/&gt;</li> <li><code>nameof</code><code>(</code><code>var</code>, <code>*more_vars</code>, <code>frame</code>, <code>vars_only</code><code>)</code> (Union) \u2014 Get the names of the variables passed in&lt;/&gt;</li> <li><code>varname</code><code>(</code><code>frame</code>, <code>ignore</code>, <code>multi_vars</code>, <code>raise_exc</code>, <code>strict</code><code>)</code> (Union) \u2014 Get the name of the variable(s) that assigned by function call orclass instantiation. &lt;/&gt;</li> <li><code>will</code><code>(</code><code>frame</code>, <code>raise_exc</code><code>)</code> (str) \u2014 Detect the attribute name right immediately after a function call.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The frame ignoring system for varname</p><p>There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame.</p> <ol> <li>Ignore frames by a given module. Any calls inside it and inside its    submodules will be ignored. A filename (path) to a module is also acceptable    and recommended when code is executed by <code>exec</code> without module available.</li> <li>Ignore frames by a given pair of module and a qualified name (qualname).    See 1) for acceptable modules. The qualname should be unique in that module.</li> <li>Ignore frames by a (non-decorated) function.</li> <li>Ignore frames by a decorated function. In this case, you can specified a    tuple with the function and the number of decorators of it. The decorators    on the wrapper function inside the decorators should also be counted.</li> </ol> <p>Any frames in <code>varname</code>, standard libraries, and frames of any expressions like  are ignored by default. Classes <ul> <li><code>IgnoreElem</code><code>(</code><code>)</code> \u2014 An element of the ignore list&lt;/&gt;</li> <li><code>IgnoreModule</code> \u2014 Ignore calls from a module or its submodules&lt;/&gt;</li> <li><code>IgnoreFilename</code> \u2014 Ignore calls from a module by matching its filename&lt;/&gt;</li> <li><code>IgnoreDirname</code> \u2014 Ignore calls from modules inside a directory&lt;/&gt;</li> <li><code>IgnoreStdlib</code> \u2014 Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True)&lt;/&gt;</li> <li><code>IgnoreFunction</code> \u2014 Ignore a non-decorated function&lt;/&gt;</li> <li><code>IgnoreDecorated</code> \u2014 Ignore a decorated function&lt;/&gt;</li> <li><code>IgnoreModuleQualname</code> \u2014 Ignore calls by qualified name in the module&lt;/&gt;</li> <li><code>IgnoreFilenameQualname</code> \u2014 Ignore calls with given qualname in the module with the filename&lt;/&gt;</li> <li><code>IgnoreOnlyQualname</code> \u2014 Ignore calls that match the given qualname, across all frames.&lt;/&gt;</li> <li><code>IgnoreList</code> \u2014 The ignore list to match the frames to see if they should be ignored&lt;/&gt;</li> </ul> Functions <ul> <li><code>create_ignore_elem</code><code>(</code><code>ignore_elem</code><code>)</code> (IgnoreElem) \u2014 Create an ignore element according to the type&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Some helper functions builtin based upon core features</p> Classes <ul> <li><code>Wrapper</code> \u2014 A wrapper with ability to retrieve the variable name&lt;/&gt;</li> </ul> Functions <ul> <li><code>debug</code><code>(</code><code>var</code>, <code>*more_vars</code>, <code>prefix</code>, <code>merge</code>, <code>repr</code>, <code>sep</code>, <code>vars_only</code><code>)</code> \u2014 Print variable names and values.&lt;/&gt;</li> <li><code>exec_code</code><code>(</code><code>code</code>, <code>globals</code>, <code>locals</code>, <code>sourcefile</code>, <code>frame</code>, <code>ignore</code>, <code>**kwargs</code><code>)</code> \u2014 Execute code where source code is visible at runtime.&lt;/&gt;</li> <li><code>jsobj</code><code>(</code><code>*args</code>, <code>vars_only</code>, <code>frame</code>, <code>**kwargs</code><code>)</code> (Dict) \u2014 A wrapper to create a JavaScript-like object&lt;/&gt;</li> <li><code>register</code><code>(</code><code>cls_or_func</code>, <code>frame</code>, <code>ignore</code>, <code>multi_vars</code>, <code>raise_exc</code>, <code>strict</code><code>)</code> (Union) \u2014 A decorator to register varname to a class or function&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Some internal utilities for varname</p> Classes <ul> <li><code>config</code> \u2014 Global configurations for varname&lt;/&gt;</li> <li><code>VarnameException</code> \u2014 Root exception for all varname exceptions&lt;/&gt;</li> <li><code>VarnameRetrievingError</code> \u2014 When failed to retrieve the varname&lt;/&gt;</li> <li><code>QualnameNonUniqueError</code> \u2014 When a qualified name is used as an ignore element but references tomultiple objects in a module &lt;/&gt;</li> <li><code>ImproperUseError</code> \u2014 When varname() is improperly used&lt;/&gt;</li> <li><code>VarnameWarning</code> \u2014 Root warning for all varname warnings&lt;/&gt;</li> <li><code>MaybeDecoratedFunctionWarning</code> \u2014 When a suspecious decorated function used as ignore function directly&lt;/&gt;</li> <li><code>MultiTargetAssignmentWarning</code> \u2014 When varname tries to retrieve variable name ina multi-target assignment &lt;/&gt;</li> <li><code>UsingExecWarning</code> \u2014 When exec is used to retrieve function name for <code>argname()</code>&lt;/&gt;</li> </ul> Functions <ul> <li><code>argnode_source</code><code>(</code><code>source</code>, <code>node</code>, <code>vars_only</code><code>)</code> (Union) \u2014 Get the source of an argument node&lt;/&gt;</li> <li><code>attach_ignore_id_to_module</code><code>(</code><code>module</code><code>)</code> \u2014 Attach the ignore id to module&lt;/&gt;</li> <li><code>bytecode_nameof</code><code>(</code><code>code</code>, <code>offset</code><code>)</code> (str) \u2014 Cached Bytecode version of nameof&lt;/&gt;</li> <li><code>cached_getmodule</code><code>(</code><code>codeobj</code><code>)</code> \u2014 Cached version of inspect.getmodule&lt;/&gt;</li> <li><code>check_qualname_by_source</code><code>(</code><code>source</code>, <code>modname</code>, <code>qualname</code><code>)</code> \u2014 Check if a qualname in module is unique&lt;/&gt;</li> <li><code>debug_ignore_frame</code><code>(</code><code>msg</code>, <code>frameinfo</code><code>)</code> \u2014 Print the debug message for a given frame info object&lt;/&gt;</li> <li><code>frame_matches_module_by_ignore_id</code><code>(</code><code>frame</code>, <code>module</code><code>)</code> (bool) \u2014 Check if the frame is from the module by ignore id&lt;/&gt;</li> <li><code>get_argument_sources</code><code>(</code><code>source</code>, <code>node</code>, <code>func</code>, <code>vars_only</code><code>)</code> (Mapping) \u2014 Get the sources for argument from an ast.Call node&lt;/&gt;</li> <li><code>get_function_called_argname</code><code>(</code><code>frame</code>, <code>node</code><code>)</code> (Callable) \u2014 Get the function who called argname&lt;/&gt;</li> <li><code>get_node</code><code>(</code><code>frame</code>, <code>ignore</code>, <code>raise_exc</code>, <code>ignore_lambda</code><code>)</code> (AST) \u2014 Try to get node from the executing object.&lt;/&gt;</li> <li><code>get_node_by_frame</code><code>(</code><code>frame</code>, <code>raise_exc</code><code>)</code> (AST) \u2014 Get the node by frame, raise errors if possible&lt;/&gt;</li> <li><code>lookfor_parent_assign</code><code>(</code><code>node</code>, <code>strict</code><code>)</code> (Union) \u2014 Look for an ast.Assign node in the parents&lt;/&gt;</li> <li><code>node_name</code><code>(</code><code>node</code>, <code>subscript_slice</code><code>)</code> (Union) \u2014 Get the node node name.&lt;/&gt;</li> <li><code>reconstruct_func_node</code><code>(</code><code>node</code><code>)</code> (Call) \u2014 Reconstruct the ast.Call node from&lt;/&gt;</li> <li><code>rich_exc_message</code><code>(</code><code>msg</code>, <code>node</code>, <code>context_lines</code><code>)</code> (str) \u2014 Attach the source code from the node to message toget a rich message for exceptions &lt;/&gt;</li> </ul>"},{"location":"api/varname/#varname","title":"varname","text":""},{"location":"api/varname/#varnamecore","title":"varname.core","text":""},{"location":"api/varname/#varnameignore","title":"varname.ignore","text":""},{"location":"api/varname/#varnamehelpers","title":"varname.helpers","text":""},{"location":"api/varname/#varnameutils","title":"varname.utils","text":""},{"location":"api/varname.utils/","title":"varname.utils","text":"module &lt;/&gt; <p>Some internal utilities for varname</p> Classes <ul> <li><code>config</code> \u2014 Global configurations for varname&lt;/&gt;</li> <li><code>VarnameException</code> \u2014 Root exception for all varname exceptions&lt;/&gt;</li> <li><code>VarnameRetrievingError</code> \u2014 When failed to retrieve the varname&lt;/&gt;</li> <li><code>QualnameNonUniqueError</code> \u2014 When a qualified name is used as an ignore element but references tomultiple objects in a module &lt;/&gt;</li> <li><code>ImproperUseError</code> \u2014 When varname() is improperly used&lt;/&gt;</li> <li><code>VarnameWarning</code> \u2014 Root warning for all varname warnings&lt;/&gt;</li> <li><code>MaybeDecoratedFunctionWarning</code> \u2014 When a suspecious decorated function used as ignore function directly&lt;/&gt;</li> <li><code>MultiTargetAssignmentWarning</code> \u2014 When varname tries to retrieve variable name ina multi-target assignment &lt;/&gt;</li> <li><code>UsingExecWarning</code> \u2014 When exec is used to retrieve function name for <code>argname()</code>&lt;/&gt;</li> </ul> Functions <ul> <li><code>argnode_source</code><code>(</code><code>source</code>, <code>node</code>, <code>vars_only</code><code>)</code> (Union) \u2014 Get the source of an argument node&lt;/&gt;</li> <li><code>attach_ignore_id_to_module</code><code>(</code><code>module</code><code>)</code> \u2014 Attach the ignore id to module&lt;/&gt;</li> <li><code>bytecode_nameof</code><code>(</code><code>code</code>, <code>offset</code><code>)</code> (str) \u2014 Cached Bytecode version of nameof&lt;/&gt;</li> <li><code>cached_getmodule</code><code>(</code><code>codeobj</code><code>)</code> \u2014 Cached version of inspect.getmodule&lt;/&gt;</li> <li><code>check_qualname_by_source</code><code>(</code><code>source</code>, <code>modname</code>, <code>qualname</code><code>)</code> \u2014 Check if a qualname in module is unique&lt;/&gt;</li> <li><code>debug_ignore_frame</code><code>(</code><code>msg</code>, <code>frameinfo</code><code>)</code> \u2014 Print the debug message for a given frame info object&lt;/&gt;</li> <li><code>frame_matches_module_by_ignore_id</code><code>(</code><code>frame</code>, <code>module</code><code>)</code> (bool) \u2014 Check if the frame is from the module by ignore id&lt;/&gt;</li> <li><code>get_argument_sources</code><code>(</code><code>source</code>, <code>node</code>, <code>func</code>, <code>vars_only</code><code>)</code> (Mapping) \u2014 Get the sources for argument from an ast.Call node&lt;/&gt;</li> <li><code>get_function_called_argname</code><code>(</code><code>frame</code>, <code>node</code><code>)</code> (Callable) \u2014 Get the function who called argname&lt;/&gt;</li> <li><code>get_node</code><code>(</code><code>frame</code>, <code>ignore</code>, <code>raise_exc</code>, <code>ignore_lambda</code><code>)</code> (AST) \u2014 Try to get node from the executing object.&lt;/&gt;</li> <li><code>get_node_by_frame</code><code>(</code><code>frame</code>, <code>raise_exc</code><code>)</code> (AST) \u2014 Get the node by frame, raise errors if possible&lt;/&gt;</li> <li><code>lookfor_parent_assign</code><code>(</code><code>node</code>, <code>strict</code><code>)</code> (Union) \u2014 Look for an ast.Assign node in the parents&lt;/&gt;</li> <li><code>node_name</code><code>(</code><code>node</code>, <code>subscript_slice</code><code>)</code> (Union) \u2014 Get the node node name.&lt;/&gt;</li> <li><code>reconstruct_func_node</code><code>(</code><code>node</code><code>)</code> (Call) \u2014 Reconstruct the ast.Call node from&lt;/&gt;</li> <li><code>rich_exc_message</code><code>(</code><code>msg</code>, <code>node</code>, <code>context_lines</code><code>)</code> (str) \u2014 Attach the source code from the node to message toget a rich message for exceptions &lt;/&gt;</li> </ul> class &lt;/&gt; <p>Global configurations for varname</p> Attributes <ul> <li><code>debug</code> \u2014 Show debug information for frames being ignored</li> </ul> class &lt;/&gt; Bases Exception BaseException <p>Root exception for all varname exceptions</p> class &lt;/&gt; Bases varname.utils.VarnameException Exception BaseException <p>When failed to retrieve the varname</p> class &lt;/&gt; Bases varname.utils.VarnameException Exception BaseException <p>When a qualified name is used as an ignore element but references tomultiple objects in a module</p> class &lt;/&gt; Bases varname.utils.VarnameException Exception BaseException <p>When varname() is improperly used</p> class &lt;/&gt; Bases Warning Exception BaseException <p>Root warning for all varname warnings</p> class &lt;/&gt; Bases varname.utils.VarnameWarning Warning Exception BaseException <p>When a suspecious decorated function used as ignore function directly</p> class &lt;/&gt; Bases varname.utils.VarnameWarning Warning Exception BaseException <p>When varname tries to retrieve variable name ina multi-target assignment</p> class &lt;/&gt; Bases varname.utils.VarnameWarning Warning Exception BaseException <p>When exec is used to retrieve function name for <code>argname()</code></p> function &lt;/&gt; <p>Cached version of inspect.getmodule</p> function &lt;/&gt; <p>Try to get node from the executing object.</p><p>This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge <code>reticulate</code>, where only first frame is kept.</p> <p>When the node can not be retrieved, try to return the first statement.</p> function &lt;/&gt; <p>Get the node by frame, raise errors if possible</p> function &lt;/&gt; <p>Look for an ast.Assign node in the parents</p> function &lt;/&gt; <p>Get the node node name.</p><p>Raises ImproperUseError when failed</p> function &lt;/&gt; <p>Cached Bytecode version of nameof</p><p>We are trying this version only when the sourcecode is unavisible. In most cases, this will happen when user is trying to run a script in REPL/ python shell, with <code>eval</code>, or other circumstances where the code is manipulated to run but sourcecode is not available.</p> function &lt;/&gt; <p>Attach the ignore id to module</p><p>This is useful when a module cannot be retrieved by frames using <code>inspect.getmodule</code>, then we can use this id, which will exist in <code>frame.f_globals</code> to check if the module matches in ignore.</p> <p>Do it only when the file is not avaiable or does not exist for the module. Since this probably means the source is not avaiable and <code>inspect.getmodule</code> would not work</p> function &lt;/&gt; <p>Check if the frame is from the module by ignore id</p> function &lt;/&gt; <p>Check if a qualname in module is unique</p> function &lt;/&gt; <p>Print the debug message for a given frame info object</p> Parameters <ul> <li><code>msg</code> (str) \u2014 The debugging message</li> <li><code>frameinfo</code> (FrameInfo, optional) \u2014 The FrameInfo object for the frame</li> </ul> function &lt;/&gt; <p>Get the source of an argument node</p> Parameters <ul> <li><code>source</code> (Source) \u2014 The executing source object</li> <li><code>node</code> (AST) \u2014 The node to get the source from</li> <li><code>vars_only</code> (bool) \u2014 Whether only allow variables and attributes</li> </ul> Returns (Union) <p>The source of the node (node.id for ast.Name,    node.attr for ast.Attribute). Or the node itself if the source     cannot be fetched.</p> function &lt;/&gt; <p>Get the sources for argument from an ast.Call node</p><pre><code>&gt;&gt;&gt; def func(a, b, c, d=4):\n&gt;&gt;&gt;  ...\n&gt;&gt;&gt; x = y = z = 1\n&gt;&gt;&gt; func(y, x, c=z)\n&gt;&gt;&gt; # argument_sources = {'a': 'y', 'b', 'x', 'c': 'z'}\n&gt;&gt;&gt; func(y, x, c=1)\n&gt;&gt;&gt; # argument_sources = {'a': 'y', 'b', 'x', 'c': ast.Num(n=1)}\n</code></pre> function &lt;/&gt; <p>Get the function who called argname</p> function &lt;/&gt; <p>Reconstruct the ast.Call node from</p><p><code>x.a</code> to <code>x.__getattr__('a')</code> <code>x.a = b</code> to <code>x.__setattr__('a', b)</code> <code>x[a]</code> to <code>x.__getitem__(a)</code> <code>x[a] = b</code> to <code>x.__setitem__(a, 1)</code> <code>x + a</code> to <code>x.__add__(a)</code> <code>x &lt; a</code> to <code>x.__lt__(a)</code></p> function &lt;/&gt; <p>Attach the source code from the node to message toget a rich message for exceptions</p> <p>If package 'rich' is not install or 'node.frame' doesn't exist, fall to plain message (with basic information), otherwise show a better message with full information</p>"},{"location":"api/varname.utils/#varnameutils","title":"varname.utils","text":""},{"location":"api/varname.utils/#varnameutilsconfig","title":"<code>varname.utils.</code><code>config</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsvarnameexception","title":"<code>varname.utils.</code><code>VarnameException</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsvarnameretrievingerror","title":"<code>varname.utils.</code><code>VarnameRetrievingError</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsqualnamenonuniqueerror","title":"<code>varname.utils.</code><code>QualnameNonUniqueError</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsimproperuseerror","title":"<code>varname.utils.</code><code>ImproperUseError</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsvarnamewarning","title":"<code>varname.utils.</code><code>VarnameWarning</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsmaybedecoratedfunctionwarning","title":"<code>varname.utils.</code><code>MaybeDecoratedFunctionWarning</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsmultitargetassignmentwarning","title":"<code>varname.utils.</code><code>MultiTargetAssignmentWarning</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsusingexecwarning","title":"<code>varname.utils.</code><code>UsingExecWarning</code><code>(</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilscached_getmodule","title":"<code>varname.utils.</code><code>cached_getmodule</code><code>(</code><code>codeobj</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsget_node","title":"<code>varname.utils.</code><code>get_node</code><code>(</code><code>frame</code>, <code>ignore=None</code>, <code>raise_exc=True</code>, <code>ignore_lambda=True</code><code>)</code> \u2192 AST","text":""},{"location":"api/varname.utils/#varnameutilsget_node_by_frame","title":"<code>varname.utils.</code><code>get_node_by_frame</code><code>(</code><code>frame</code>, <code>raise_exc=True</code><code>)</code> \u2192 AST","text":""},{"location":"api/varname.utils/#varnameutilslookfor_parent_assign","title":"<code>varname.utils.</code><code>lookfor_parent_assign</code><code>(</code><code>node</code>, <code>strict=True</code><code>)</code> \u2192 Union","text":""},{"location":"api/varname.utils/#varnameutilsnode_name","title":"<code>varname.utils.</code><code>node_name</code><code>(</code><code>node</code>, <code>subscript_slice=False</code><code>)</code> \u2192 Union","text":""},{"location":"api/varname.utils/#varnameutilsbytecode_nameof","title":"<code>varname.utils.</code><code>bytecode_nameof</code><code>(</code><code>code</code>, <code>offset</code><code>)</code> \u2192 str","text":""},{"location":"api/varname.utils/#varnameutilsattach_ignore_id_to_module","title":"<code>varname.utils.</code><code>attach_ignore_id_to_module</code><code>(</code><code>module</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsframe_matches_module_by_ignore_id","title":"<code>varname.utils.</code><code>frame_matches_module_by_ignore_id</code><code>(</code><code>frame</code>, <code>module</code><code>)</code> \u2192 bool","text":""},{"location":"api/varname.utils/#varnameutilscheck_qualname_by_source","title":"<code>varname.utils.</code><code>check_qualname_by_source</code><code>(</code><code>source</code>, <code>modname</code>, <code>qualname</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsdebug_ignore_frame","title":"<code>varname.utils.</code><code>debug_ignore_frame</code><code>(</code><code>msg</code>, <code>frameinfo=None</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsargnode_source","title":"<code>varname.utils.</code><code>argnode_source</code><code>(</code><code>source</code>, <code>node</code>, <code>vars_only</code><code>)</code>","text":""},{"location":"api/varname.utils/#varnameutilsget_argument_sources","title":"<code>varname.utils.</code><code>get_argument_sources</code><code>(</code><code>source</code>, <code>node</code>, <code>func</code>, <code>vars_only</code><code>)</code> \u2192 Mapping","text":""},{"location":"api/varname.utils/#varnameutilsget_function_called_argname","title":"<code>varname.utils.</code><code>get_function_called_argname</code><code>(</code><code>frame</code>, <code>node</code><code>)</code> \u2192 Callable","text":""},{"location":"api/varname.utils/#varnameutilsreconstruct_func_node","title":"<code>varname.utils.</code><code>reconstruct_func_node</code><code>(</code><code>node</code><code>)</code> \u2192 Call","text":""},{"location":"api/varname.utils/#varnameutilsrich_exc_message","title":"<code>varname.utils.</code><code>rich_exc_message</code><code>(</code><code>msg</code>, <code>node</code>, <code>context_lines=4</code><code>)</code> \u2192 str","text":""},{"location":"api/source/varname.core/","title":"varname.core","text":""},{"location":"api/source/varname.core/","title":"SOURCE CODE varname.core DOCS","text":"<pre><code>\"\"\"Provide core features for varname\"\"\"\nfrom __future__ import annotations\nimport ast\nimport re\nimport warnings\nfrom typing import Any, List, Union, Tuple, Type, Callable, overload\n\nfrom executing import Source\n\nfrom .utils import (\n    bytecode_nameof,\n    get_node,\n    get_node_by_frame,\n    lookfor_parent_assign,\n    node_name,\n    get_argument_sources,\n    get_function_called_argname,\n    rich_exc_message,\n    reconstruct_func_node,\n    ArgSourceType,\n    VarnameRetrievingError,\n    ImproperUseError,\n    MultiTargetAssignmentWarning,\n)\nfrom .ignore import IgnoreList, IgnoreType\n\n\ndef varname(DOCS\n    frame: int = 1,\n    ignore: IgnoreType = None,\n    multi_vars: bool = False,\n    raise_exc: bool = True,\n    strict: bool = True,\n) -&gt; Union[str, Tuple[Union[str, Tuple], ...]]:\n    \"\"\"Get the name of the variable(s) that assigned by function call or\n    class instantiation.\n\n    To debug and specify the right frame and ignore arguments, you can set\n    debug on and see how the frames are ignored or selected:\n\n    &gt;&gt;&gt; from varname import config\n    &gt;&gt;&gt; config.debug = True\n\n    Args:\n        frame: `N`th frame used to retrieve the variable name. This means\n            `N-1` intermediate frames will be skipped. Note that the frames\n            match `ignore` will not be counted. See `ignore` for details.\n        ignore: Frames to be ignored in order to reach the `N`th frame.\n            These frames will not be counted to skip within that `N-1` frames.\n            You can specify:\n            - A module (or filename of a module). Any calls from it and its\n                submodules will be ignored.\n            - A function. If it looks like it might be a decorated function,\n                a `MaybeDecoratedFunctionWarning` will be shown.\n            - Tuple of a function and a number of additional frames that should\n                be skipped just before reaching this function in the stack.\n                This is typically used for functions that have been decorated\n                with a 'classic' decorator that replaces the function with\n                a wrapper. In that case each such decorator involved should\n                be counted in the number that's the second element of the tuple.\n            - Tuple of a module (or filename) and qualified name (qualname).\n                You can use Unix shell-style wildcards to match the qualname.\n                Otherwise the qualname must appear exactly once in the\n                module/file.\n            By default, all calls from `varname` package, python standard\n            libraries and lambda functions are ignored.\n        multi_vars: Whether allow multiple variables on left-hand side (LHS).\n            If `True`, this function returns a tuple of the variable names,\n            even there is only one variable on LHS.\n            If `False`, and multiple variables on LHS, a\n            `ImproperUseError` will be raised.\n        raise_exc: Whether we should raise an exception if failed\n            to retrieve the ast node.\n            Note that set this to `False` will NOT supress the exception when\n            the use of `varname` is improper (i.e. multiple variables on\n            LHS with `multi_vars` is `False`). See `Raises/ImproperUseError`.\n        strict: Whether to only return the variable name(s) if the result of\n            the call is assigned to it/them directly. For example, `a = func()`\n            rather than `a = [func()]`\n\n    Returns:\n        The variable name, or `None` when `raise_exc` is `False` and\n            we failed to retrieve the ast node for the variable(s).\n        A tuple or a hierarchy (tuple of tuples) of variable names\n            when `multi_vars` is `True`.\n\n    Raises:\n        VarnameRetrievingError: When we are unable to retrieve the ast node\n            for the variable(s) and `raise_exc` is set to `True`.\n\n        ImproperUseError: When the use of `varname()` is improper, including:\n            - When LHS is not an `ast.Name` or `ast.Attribute` node or not a\n                list/tuple of them\n            - When there are multiple variables on LHS but `multi_vars` is False\n            - When `strict` is True, but the result is not assigned to\n                variable(s) directly\n\n            Note that `raise_exc=False` will NOT suppress this exception.\n\n        MultiTargetAssignmentWarning: When there are multiple target\n            in the assign node. (e.g: `a = b = func()`, in such a case,\n            `a == 'b'`, may not be the case you want)\n    \"\"\"\n    # Skip one more frame, as it is supposed to be called\n    # inside another function\n    refnode = get_node(frame + 1, ignore, raise_exc=raise_exc)\n    if not refnode:\n        if raise_exc:\n            raise VarnameRetrievingError(\"Unable to retrieve the ast node.\")\n        return None\n\n    node = lookfor_parent_assign(refnode, strict=strict)\n    if not node:  # improper use\n        if strict:\n            msg = \"Caller doesn't assign the result directly to variable(s).\"\n        else:\n            msg = \"Expression is not part of an assignment.\"\n\n        raise ImproperUseError(rich_exc_message(msg, refnode))\n\n    if isinstance(node, ast.Assign):\n        # Need to actually check that there's just one\n        # give warnings if: a = b = func()\n        if len(node.targets) &gt; 1:\n            warnings.warn(\n                \"Multiple targets in assignment, variable name \"\n                \"on the very right is used. \",\n                MultiTargetAssignmentWarning,\n            )\n        target = node.targets[-1]\n    else:\n        target = node.target\n\n    names = node_name(target)\n\n    if not isinstance(names, tuple):\n        names = (names,)\n\n    if multi_vars:\n        return names\n\n    if len(names) &gt; 1:\n        raise ImproperUseError(\n            rich_exc_message(\n                \"Expect a single variable on left-hand side, \"\n                f\"got {len(names)}.\",\n                refnode,\n            )\n        )\n\n    return names[0]\n\n\ndef will(frame: int = 1, raise_exc: bool = True) -&gt; str:DOCS\n    \"\"\"Detect the attribute name right immediately after a function call.\n\n    Examples:\n        &gt;&gt;&gt; class AwesomeClass:\n        &gt;&gt;&gt;     def __init__(self):\n        &gt;&gt;&gt;         self.will = None\n\n        &gt;&gt;&gt;     def permit(self):\n        &gt;&gt;&gt;         self.will = will()\n        &gt;&gt;&gt;         if self.will == 'do':\n        &gt;&gt;&gt;             # let self handle do\n        &gt;&gt;&gt;             return self\n        &gt;&gt;&gt;         raise AttributeError(\n        &gt;&gt;&gt;             'Should do something with AwesomeClass object'\n        &gt;&gt;&gt;         )\n\n        &gt;&gt;&gt;     def do(self):\n        &gt;&gt;&gt;         if self.will != 'do':\n        &gt;&gt;&gt;             raise AttributeError(\"You don't have permission to do\")\n        &gt;&gt;&gt;         return 'I am doing!'\n\n        &gt;&gt;&gt; awesome = AwesomeClass()\n        &gt;&gt;&gt; # AttributeError: You don't have permission to do\n        &gt;&gt;&gt; awesome.do()\n        &gt;&gt;&gt; # AttributeError: Should do something with AwesomeClass object\n        &gt;&gt;&gt; awesome.permit()\n        &gt;&gt;&gt; awesome.permit().do() == 'I am doing!'\n\n    Args:\n        frame: At which frame this function is called.\n        raise_exc: Raise exception we failed to detect the ast node\n            This will NOT supress the `ImproperUseError`\n\n    Returns:\n        The attribute name right after the function call.\n        `None` if ast node cannot be retrieved and `raise_exc` is `False`\n\n    Raises:\n        VarnameRetrievingError: When `raise_exc` is `True` and we failed to\n            detect the attribute name (including not having one)\n\n        ImproperUseError: When (the wraper of) this function is not called\n            inside a method/property of a class instance.\n            Note that this exception will not be suppressed by `raise_exc=False`\n    \"\"\"\n    node = get_node(frame + 1, raise_exc=raise_exc)\n    if not node:\n        if raise_exc:\n            raise VarnameRetrievingError(\"Unable to retrieve the frame.\")\n        return None\n\n    # try to get node inst.attr from inst.attr()\n    node = node.parent\n\n    # see test_will_fail\n    if not isinstance(node, ast.Attribute):\n        if raise_exc:\n            raise ImproperUseError(\n                \"Function `will` has to be called within \"\n                \"a method/property of a class.\"\n            )\n        return None\n    # ast.Attribute\n    return node.attr\n\n\n@overload\ndef nameof(\n    var: Any,\n    *,\n    frame: int = 1,\n    vars_only: bool = True,\n) -&gt; str:  # pragma: no cover\n    ...\n\n\n@overload\ndef nameof(\n    var: Any,\n    more_var: Any,\n    /,  # introduced in python 3.8\n    *more_vars: Any,\n    frame: int = 1,\n    vars_only: bool = True,\n) -&gt; Tuple[str, ...]:  # pragma: no cover\n    ...\n\n\ndef nameof(DOCS\n    var: Any,\n    *more_vars: Any,\n    frame: int = 1,\n    vars_only: bool = True,\n) -&gt; Union[str, Tuple[str, ...]]:\n    \"\"\"Get the names of the variables passed in\n\n    Examples:\n        &gt;&gt;&gt; a = 1\n        &gt;&gt;&gt; nameof(a) # 'a'\n\n        &gt;&gt;&gt; b = 2\n        &gt;&gt;&gt; nameof(a, b) # ('a', 'b')\n\n        &gt;&gt;&gt; x = lambda: None\n        &gt;&gt;&gt; x.y = 1\n        &gt;&gt;&gt; nameof(x.y, vars_only=False) # 'x.y'\n\n    Note:\n        This function works with the environments where source code is\n        available, in other words, the callee's node can be retrieved by\n        `executing`. In some cases, for example, running code from python\n        shell/REPL or from `exec`/`eval`, we try to fetch the variable name\n        from the bytecode. This requires only a single variable name is passed\n        to this function and no keyword arguments, meaning that getting full\n        names of attribute calls are not supported in such cases.\n\n    Args:\n        var: The variable to retrieve the name of\n        *more_vars: Other variables to retrieve the names of\n        frame: The this function is called from the wrapper of it. `frame=1`\n            means no wrappers.\n            Note that the calls from standard libraries are ignored.\n            Also note that the wrapper has to have signature as this one.\n        vars_only: Whether only allow variables/attributes as arguments or\n            any expressions. If `False`, then the sources of the arguments\n            will be returned.\n\n    Returns:\n        The names/sources of variables/expressions passed in.\n            If a single argument is passed, return the name/source of it.\n            If multiple variables are passed, return a tuple of their\n            names/sources.\n            If the argument is an attribute (e.g. `a.b`) and `vars_only` is\n            `True`, only `\"b\"` will returned. Set `vars_only` to `False` to\n            get `\"a.b\"`.\n\n    Raises:\n        VarnameRetrievingError: When the callee's node cannot be retrieved or\n            trying to retrieve the full name of non attribute series calls.\n    \"\"\"\n    # Frame is anyway used in get_node\n    frameobj = IgnoreList.create(\n        ignore_lambda=False,\n        ignore_varname=False,\n    ).get_frame(frame)\n\n    node = get_node_by_frame(frameobj, raise_exc=True)\n    if not node:\n        # We can't retrieve the node by executing.\n        # It can be due to running code from python/shell, exec/eval or\n        # other environments where sourcecode cannot be reached\n        # make sure we keep it simple (only single variable passed and no\n        # full passed) to use bytecode_nameof\n        #\n        # We don't have to check keyword arguments here, as the instruction\n        # will then be CALL_FUNCTION_KW.\n        if not more_vars:\n            return bytecode_nameof(frameobj.f_code, frameobj.f_lasti)\n\n        # We are anyway raising exceptions, no worries about additional burden\n        # of frame retrieval again\n        source = frameobj.f_code.co_filename\n        if source == \"&lt;stdin&gt;\":\n            raise VarnameRetrievingError(\n                \"Are you trying to call nameof in REPL/python shell? \"\n                \"In such a case, nameof can only be called with single \"\n                \"argument and no keyword arguments.\"\n            )\n        if source == \"&lt;string&gt;\":\n            raise VarnameRetrievingError(\n                \"Are you trying to call nameof from exec/eval? \"\n                \"In such a case, nameof can only be called with single \"\n                \"argument and no keyword arguments.\"\n            )\n        raise VarnameRetrievingError(\n            \"Source code unavailable, nameof can only retrieve the name of \"\n            \"a single variable, and argument `full` should not be specified.\"\n        )\n\n    out = argname(\n        \"var\",\n        \"*more_vars\",\n        func=nameof,\n        frame=frame,\n        vars_only=vars_only,\n    )\n    return out if more_vars else out[0]  # type: ignore\n\n\n@overload\ndef argname(\n    arg: str,\n    *,\n    func: Callable = None,\n    dispatch: Type = None,\n    frame: int = 1,\n    ignore: IgnoreType = None,\n    vars_only: bool = True,\n) -&gt; ArgSourceType:  # pragma: no cover\n    ...\n\n\n@overload\ndef argname(\n    arg: str,\n    more_arg: str,\n    /,  # introduced in python 3.8\n    *more_args: str,\n    func: Callable = None,\n    dispatch: Type = None,\n    frame: int = 1,\n    ignore: IgnoreType = None,\n    vars_only: bool = True,\n) -&gt; Tuple[ArgSourceType, ...]:  # pragma: no cover\n    ...\n\n\ndef argname(DOCS\n    arg: str,\n    *more_args: str,\n    func: Callable = None,\n    dispatch: Type = None,\n    frame: int = 1,\n    ignore: IgnoreType = None,\n    vars_only: bool = True,\n) -&gt; Union[ArgSourceType, Tuple[ArgSourceType, ...]]:\n    \"\"\"Get the names/sources of arguments passed to a function.\n\n    Instead of passing the argument variables themselves to this function\n    (like `argname()` does), you should pass their names instead.\n\n    Args:\n        arg: and\n        *more_args: The names of the arguments that you want to retrieve\n            names/sources of.\n            You can also use subscripts to get parts of the results.\n            &gt;&gt;&gt; def func(*args, **kwargs):\n            &gt;&gt;&gt;     return argname('args[0]', 'kwargs[x]') # no quote needed\n\n            Star argument is also allowed:\n            &gt;&gt;&gt; def func(*args, x = 1):\n            &gt;&gt;&gt;     return argname('*args', 'x')\n            &gt;&gt;&gt; a = b = c = 1\n            &gt;&gt;&gt; func(a, b, x=c) # ('a', 'b', 'c')\n\n            Note the difference:\n            &gt;&gt;&gt; def func(*args, x = 1):\n            &gt;&gt;&gt;     return argname('args', 'x')\n            &gt;&gt;&gt; a = b = c = 1\n            &gt;&gt;&gt; func(a, b, x=c) # (('a', 'b'), 'c')\n\n        func: The target function. If not provided, the AST node of the\n            function call will be used to fetch the function:\n            - If a variable (ast.Name) used as function, the `node.id` will\n                be used to get the function from `locals()` or `globals()`.\n            - If variable (ast.Name), attributes (ast.Attribute),\n                subscripts (ast.Subscript), and combinations of those and\n                literals used as function, `pure_eval` will be used to evaluate\n                the node\n            - If `pure_eval` is not installed or failed to evaluate, `eval`\n                will be used. A warning will be shown since unwanted side\n                effects may happen in this case.\n            You are very encouraged to always pass the function explicitly.\n        dispatch: If a function is a single-dispatched function, you can\n            specify a type for it to dispatch the real function. If this is\n            specified, expect `func` to be the generic function if provided.\n        frame: The frame where target function is called from this call.\n            Calls from python standard libraries are ignored.\n        ignore: The intermediate calls to be ignored. See `varname.ignore`\n        vars_only: Require the arguments to be variables only.\n            If False, `asttokens` is required to retrieve the source.\n\n    Returns:\n        The argument source when no more_args passed, otherwise a tuple of\n        argument sources\n        Note that when an argument is an `ast.Constant`, `repr(arg.value)`\n        is returned, so `argname()` return `'a'` for `func(\"a\")`\n\n    Raises:\n        VarnameRetrievingError: When the ast node where the function is called\n            cannot be retrieved\n        ImproperUseError: When frame or func is incorrectly specified.\n    \"\"\"\n    ignore_list = IgnoreList.create(\n        ignore,\n        ignore_lambda=False,\n        ignore_varname=False,\n    )\n    # where func(...) is called, skip the argname() call\n    func_frame = ignore_list.get_frame(frame + 1)\n    func_node = get_node_by_frame(func_frame)\n    # Only do it when func_node are available\n    if not func_node:\n        # We can do something at bytecode level, when a single positional\n        # argument passed to both functions (argname and the target function)\n        # However, it's hard to ensure that there is only a single positional\n        # arguments passed to the target function, at bytecode level.\n        raise VarnameRetrievingError(\n            \"Cannot retrieve the node where the function is called.\"\n        )\n\n    func_node = reconstruct_func_node(func_node)\n\n    if not func:\n        func = get_function_called_argname(func_frame, func_node)\n\n    if dispatch:\n        func = func.dispatch(dispatch)\n\n    # don't pass the target arguments so that we can cache the sources in\n    # the same call. For example:\n    # &gt;&gt;&gt; def func(a, b):\n    # &gt;&gt;&gt;   a_name = argname(a)\n    # &gt;&gt;&gt;   b_name = argname(b)\n    try:\n        argument_sources = get_argument_sources(\n            Source.for_frame(func_frame),\n            func_node,\n            func,\n            vars_only=vars_only,\n        )\n    except Exception as err:\n        raise ImproperUseError(\n            \"Have you specified the right `frame` or `func`?\"\n        ) from err\n\n    out: List[ArgSourceType] = []\n    farg_star = False\n    for farg in (arg, *more_args):\n\n        farg_name = farg\n        farg_subscript = None  # type: str | int\n        match = re.match(r\"^([\\w_]+)\\[(.+)\\]$\", farg)\n        if match:\n            farg_name = match.group(1)\n            farg_subscript = match.group(2)\n            if farg_subscript.isdigit():\n                farg_subscript = int(farg_subscript)\n        else:\n            match = re.match(r\"^\\*([\\w_]+)$\", farg)\n            if match:\n                farg_name = match.group(1)\n                farg_star = True\n\n        if farg_name not in argument_sources:\n            raise ImproperUseError(\n                f\"{farg_name!r} is not a valid argument \"\n                f\"of {func.__qualname__!r}.\"\n            )\n\n        source = argument_sources[farg_name]\n        if isinstance(source, ast.AST):\n            raise ImproperUseError(\n                f\"Argument {ast.dump(source)} is not a variable \"\n                \"or an attribute.\"\n            )\n\n        if isinstance(farg_subscript, int) and not isinstance(source, tuple):\n            raise ImproperUseError(\n                f\"`{farg_name}` is not a positional argument.\"\n            )\n\n        if isinstance(farg_subscript, str) and not isinstance(source, dict):\n            raise ImproperUseError(\n                f\"`{farg_name}` is not a keyword argument.\"\n            )\n\n        if farg_subscript is not None:\n            out.append(source[farg_subscript])  # type: ignore\n        elif farg_star:\n            out.extend(source)\n        else:\n            out.append(source)\n\n    return (\n        out[0]\n        if not more_args and not farg_star\n        else tuple(out)  # type: ignore\n    )\n</code></pre>"},{"location":"api/source/varname.helpers/","title":"varname.helpers","text":""},{"location":"api/source/varname.helpers/","title":"SOURCE CODE varname.helpers DOCS","text":"<pre><code>\"\"\"Some helper functions builtin based upon core features\"\"\"\nfrom __future__ import annotations\n\nimport inspect\nfrom functools import partial, wraps\nfrom os import PathLike\nfrom typing import Any, Callable, Dict, Tuple, Type, Union\n\nfrom .utils import IgnoreType\nfrom .ignore import IgnoreList\nfrom .core import argname, varname\n\n\ndef register(DOCS\n    cls_or_func: type = None,\n    frame: int = 1,\n    ignore: IgnoreType = None,\n    multi_vars: bool = False,\n    raise_exc: bool = True,\n    strict: bool = True,\n) -&gt; Union[Type, Callable]:\n    \"\"\"A decorator to register __varname__ to a class or function\n\n    When registered to a class, it can be accessed by `self.__varname__`;\n    while to a function, it is registered to globals, meaning that it can be\n    accessed directly.\n\n    Args:\n        frame: The call stack index, indicating where this class\n            is instantiated relative to where the variable is finally retrieved\n        multi_vars: Whether allow multiple variables on left-hand side (LHS).\n            If `True`, this function returns a tuple of the variable names,\n            even there is only one variable on LHS.\n            If `False`, and multiple variables on LHS, a\n            `VarnameRetrievingError` will be raised.\n        raise_exc: Whether we should raise an exception if failed\n            to retrieve the name.\n        strict: Whether to only return the variable name if the result of\n            the call is assigned to it directly.\n\n    Examples:\n        &gt;&gt;&gt; @varname.register\n        &gt;&gt;&gt; class Foo: pass\n        &gt;&gt;&gt; foo = Foo()\n        &gt;&gt;&gt; # foo.__varname__ == 'foo'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; @varname.register\n        &gt;&gt;&gt; def func():\n        &gt;&gt;&gt;   return __varname__\n        &gt;&gt;&gt; foo = func() # foo == 'foo'\n\n    Returns:\n        The wrapper function or the class/function itself\n        if it is specified explictly.\n    \"\"\"\n    if inspect.isclass(cls_or_func):\n        orig_init = cls_or_func.__init__  # type: ignore\n\n        @wraps(cls_or_func.__init__)  # type: ignore\n        def wrapped_init(self, *args, **kwargs):\n            \"\"\"Wrapped init function to replace the original one\"\"\"\n            self.__varname__ = varname(\n                frame - 1,\n                ignore=ignore,\n                multi_vars=multi_vars,\n                raise_exc=raise_exc,\n                strict=strict,\n            )\n            orig_init(self, *args, **kwargs)\n\n        cls_or_func.__init__ = wrapped_init  # type: ignore\n        return cls_or_func\n\n    if inspect.isfunction(cls_or_func):\n\n        @wraps(cls_or_func)\n        def wrapper(*args, **kwargs):\n            \"\"\"The wrapper to register `__varname__` to a function\"\"\"\n            cls_or_func.__globals__[\"__varname__\"] = varname(\n                frame - 1,\n                ignore=ignore,\n                multi_vars=multi_vars,\n                raise_exc=raise_exc,\n                strict=strict,\n            )\n\n            try:\n                return cls_or_func(*args, **kwargs)\n            finally:\n                del cls_or_func.__globals__[\"__varname__\"]\n\n        return wrapper\n\n    # None, meaning we have other arguments\n    return partial(\n        register,\n        frame=frame,\n        ignore=ignore,\n        multi_vars=multi_vars,\n        raise_exc=raise_exc,\n        strict=strict,\n    )\n\n\nclass Wrapper:DOCS\n    \"\"\"A wrapper with ability to retrieve the variable name\n\n    Examples:\n        &gt;&gt;&gt; foo = Wrapper(True)\n        &gt;&gt;&gt; # foo.name == 'foo'\n        &gt;&gt;&gt; # foo.value == True\n\n        &gt;&gt;&gt; val = {}\n        &gt;&gt;&gt; bar = Wrapper(val)\n        &gt;&gt;&gt; # bar.name == 'bar'\n        &gt;&gt;&gt; # bar.value is val\n\n    Args:\n        value: The value to be wrapped\n        raise_exc: Whether to raise exception when varname is failed to retrieve\n        strict: Whether to only return the variable name if the wrapper is\n            assigned to it directly.\n\n    Attributes:\n        name: The variable name to which the instance is assigned\n        value: The value this wrapper wraps\n    \"\"\"\n\n    def __init__(\n        self,\n        value: Any,\n        frame: int = 1,\n        ignore: IgnoreType = None,\n        raise_exc: bool = True,\n        strict: bool = True,\n    ):\n        # This call is ignored, since it's inside varname\n        self.name = varname(\n            frame=frame - 1,\n            ignore=ignore,\n            raise_exc=raise_exc,\n            strict=strict,\n        )\n        self.value = value\n\n    def __str__(self) -&gt; str:\n        return repr(self.value)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;{self.__class__.__name__} \"\n            f\"(name={self.name!r}, value={self.value!r})&gt;\"\n        )\n\n\ndef jsobj(DOCS\n    *args: Any,\n    vars_only: bool = True,\n    frame: int = 1,\n    **kwargs: Any,\n) -&gt; Dict[str, Any]:\n    \"\"\"A wrapper to create a JavaScript-like object\n\n    When an argument is passed as positional argument, the name of the variable\n    will be used as the key, while the value will be used as the value.\n\n    Examples:\n        &gt;&gt;&gt; obj = jsobj(a=1, b=2)\n        &gt;&gt;&gt; # obj == {'a': 1, 'b': 2}\n        &gt;&gt;&gt; # obj.a == 1\n        &gt;&gt;&gt; # obj.b == 2\n        &gt;&gt;&gt; a = 1\n        &gt;&gt;&gt; b = 2\n        &gt;&gt;&gt; obj = jsobj(a, b, c=3)\n        &gt;&gt;&gt; # obj == {'a': 1, 'b': 2, 'c': 3}\n\n    Args:\n        *args: The positional arguments\n        vars_only: Whether to only include variables in the output\n        frame: The call stack index. You can understand this as the number of\n            wrappers around this function - 1.\n        **kwargs: The keyword arguments\n\n    Returns:\n        A dict-like object\n    \"\"\"\n    argnames: Tuple[str, ...] = argname(\n        \"args\",\n        vars_only=vars_only,\n        frame=frame,\n    )  # type: ignore\n    out = dict(zip(argnames, args))\n    out.update(kwargs)\n    return out\n\n\ndef debug(DOCS\n    var,\n    *more_vars,\n    prefix: str = \"DEBUG: \",\n    merge: bool = False,\n    repr: bool = True,\n    sep: str = \"=\",\n    vars_only: bool = False,\n) -&gt; None:\n    \"\"\"Print variable names and values.\n\n    Examples:\n        &gt;&gt;&gt; a = 1\n        &gt;&gt;&gt; b = object\n        &gt;&gt;&gt; print(f'a={a}') # previously, we have to do\n        &gt;&gt;&gt; print(f'{a=}')  # or with python3.8\n        &gt;&gt;&gt; # instead we can do:\n        &gt;&gt;&gt; debug(a) # DEBUG: a=1\n        &gt;&gt;&gt; debug(a, prefix='') # a=1\n        &gt;&gt;&gt; debug(a, b, merge=True) # a=1, b=&lt;object object at 0x2b9a4c89cf00&gt;\n\n    Args:\n        var: The variable to print\n        *more_vars: Other variables to print\n        prefix: A prefix to print for each line\n        merge: Whether merge all variables in one line or not\n        sep: The separator between the variable name and value\n        repr: Print the value as `repr(var)`? otherwise `str(var)`\n    \"\"\"\n    var_names = argname(\"var\", \"*more_vars\", vars_only=vars_only, func=debug)\n\n    values = (var, *more_vars)\n    name_and_values = [\n        f\"{var_name}{sep}{value!r}\" if repr else f\"{var_name}{sep}{value}\"\n        for var_name, value in zip(var_names, values)  # type: ignore\n    ]\n\n    if merge:\n        print(f\"{prefix}{', '.join(name_and_values)}\")\n    else:\n        for name_and_value in name_and_values:\n            print(f\"{prefix}{name_and_value}\")\n\n\ndef exec_code(DOCS\n    code: str,\n    globals: Dict[str, Any] = None,\n    locals: Dict[str, Any] = None,\n    /,\n    sourcefile: PathLike | str = None,\n    frame: int = 1,\n    ignore: IgnoreType = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Execute code where source code is visible at runtime.\n\n    This function is useful when you want to execute some code, where you want to\n    retrieve the AST node of the code at runtime. This function will create a\n    temporary file and write the code into it, then execute the code in the\n    file.\n\n    Examples:\n        &gt;&gt;&gt; from varname import varname\n        &gt;&gt;&gt; def func(): return varname()\n        &gt;&gt;&gt; exec('var = func()')  # VarnameRetrievingError:\n        &gt;&gt;&gt;                       #  Unable to retrieve the ast node.\n        &gt;&gt;&gt; from varname.helpers import code_exec\n        &gt;&gt;&gt; code_exec('var = func()')  # var == 'var'\n\n    Args:\n        code: The code to execute.\n        globals: The globals to use.\n        locals: The locals to use.\n        sourcefile: The source file to write the code into.\n            if not given, a temporary file will be used.\n            This file will be deleted after the code is executed.\n        frame: The call stack index. You can understand this as the number of\n            wrappers around this function. This is used to fetch `globals` and\n            `locals` from where the destination function (include the wrappers\n            of this function)\n            is called.\n        ignore: The intermediate calls to be ignored. See `varname.ignore`\n            Note that if both `globals` and `locals` are given, `frame` and\n            `ignore` will be ignored.\n        **kwargs: The keyword arguments to pass to `exec`.\n    \"\"\"\n    if sourcefile is None:\n        import tempfile\n\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", suffix=\".py\", delete=False\n        ) as f:\n            f.write(code)\n            sourcefile = f.name\n    else:\n        sourcefile = str(sourcefile)\n        with open(sourcefile, \"w\") as f:\n            f.write(code)\n\n    if globals is None or locals is None:\n        ignore_list = IgnoreList.create(ignore)\n        frame_info = ignore_list.get_frame(frame)\n        if globals is None:\n            globals = frame_info.f_globals\n        if locals is None:\n            locals = frame_info.f_locals\n\n    try:\n        exec(compile(code, sourcefile, \"exec\"), globals, locals, **kwargs)\n    finally:\n        import os\n\n        os.remove(sourcefile)\n</code></pre>"},{"location":"api/source/varname.ignore/","title":"varname.ignore","text":""},{"location":"api/source/varname.ignore/","title":"SOURCE CODE varname.ignore DOCS","text":"<pre><code>\"\"\"The frame ignoring system for varname\n\nThere 4 mechanisms to ignore intermediate frames to determine the desired one\nso that a variable name should be retrieved at that frame.\n\n1. Ignore frames by a given module. Any calls inside it and inside its\n   submodules will be ignored. A filename (path) to a module is also acceptable\n   and recommended when code is executed by `exec` without module available.\n2. Ignore frames by a given pair of module and a qualified name (qualname).\n   See 1) for acceptable modules. The qualname should be unique in that module.\n3. Ignore frames by a (non-decorated) function.\n4. Ignore frames by a decorated function. In this case, you can specified a\n   tuple with the function and the number of decorators of it. The decorators\n   on the wrapper function inside the decorators should also be counted.\n\nAny frames in `varname`, standard libraries, and frames of any expressions like\n&lt;lambda&gt; are ignored by default.\n\n\"\"\"\nimport sys\nimport inspect\nimport warnings\nfrom os import path\nfrom pathlib import Path\nfrom fnmatch import fnmatch\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union\nfrom types import FrameType, ModuleType, FunctionType\n\nfrom executing import Source\n\ntry:\n    import sysconfig  # 3.10+\nexcept ImportError:  # pragma: no cover\n    from distutils import sysconfig\n    STANDLIB_PATH = sysconfig.get_python_lib(standard_lib=True)\nelse:\n    STANDLIB_PATH = sysconfig.get_path('stdlib')\n\nfrom .utils import (\n    IgnoreElemType,\n    IgnoreType,\n    MaybeDecoratedFunctionWarning,\n    cached_getmodule,\n    attach_ignore_id_to_module,\n    frame_matches_module_by_ignore_id,\n    check_qualname_by_source,\n    debug_ignore_frame,\n)\n\n\nclass IgnoreElem(ABC):DOCS\n    \"\"\"An element of the ignore list\"\"\"\n\n    def __init_subclass__(cls, attrs: List[str]) -&gt; None:DOCS\n        \"\"\"Define different attributes for subclasses\"\"\"\n\n        def subclass_init(\n            self,\n            # IgnoreModule: ModuleType\n            # IgnoreFilename/IgnoreDirname: str\n            # IgnoreFunction: FunctionType\n            # IgnoreDecorated: FunctionType, int\n            # IgnoreModuleQualname/IgnoreFilenameQualname:\n            #   ModuleType/str, str\n            # IgnoreOnlyQualname: None, str\n            *ign_args: Union[str, int, ModuleType, FunctionType],\n        ) -&gt; None:\n            \"\"\"__init__ function for subclasses\"\"\"\n            for attr, arg in zip(attrs, ign_args):\n                setattr(self, attr, arg)\n\n            self._post_init()\n\n        # save it for __repr__\n        cls.attrs = attrs\n        cls.__init__ = subclass_init  # type: ignore\n\n    def _post_init(self) -&gt; None:\n        \"\"\"Setups after __init__\"\"\"\n\n    @abstractmethodDOCS\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        \"\"\"Whether the frame matches the ignore element\"\"\"\n\n    def __repr__(self) -&gt; str:DOCS\n        \"\"\"Representation of the element\"\"\"\n        attr_values = (getattr(self, attr) for attr in self.__class__.attrs)\n        # get __name__ if possible\n        attr_values = (\n            repr(getattr(attr_value, \"__name__\", attr_value))\n            for attr_value in attr_values\n        )\n        attr_values = \", \".join(attr_values)\n        return f\"{self.__class__.__name__}({attr_values})\"\n\n\nclass IgnoreModule(IgnoreElem, attrs=[\"module\"]):DOCS\n    \"\"\"Ignore calls from a module or its submodules\"\"\"\n\n    def _post_init(self) -&gt; None:\n        attach_ignore_id_to_module(self.module)\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        frame = frameinfos[frame_no].frame\n        module = cached_getmodule(frame.f_code)\n        if module:\n            return (\n                module.__name__ == self.module.__name__\n                or module.__name__.startswith(f\"{self.module.__name__}.\")\n            )\n\n        return frame_matches_module_by_ignore_id(frame, self.module)\n\n\nclass IgnoreFilename(IgnoreElem, attrs=[\"filename\"]):\n    \"\"\"Ignore calls from a module by matching its filename\"\"\"\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        frame = frameinfos[frame_no].frame\n\n        # in case of symbolic links\n        return path.realpath(frame.f_code.co_filename) == path.realpath(\n            self.filename\n        )\n\n\nclass IgnoreDirname(IgnoreElem, attrs=[\"dirname\"]):\n    \"\"\"Ignore calls from modules inside a directory\n\n    Currently used internally to ignore calls from standard libraries.\"\"\"\n\n    def _post_init(self) -&gt; None:\n\n        # Path object will turn into str here\n        self.dirname = path.realpath(self.dirname)  # type: str\n\n        if not self.dirname.endswith(path.sep):\n            self.dirname = f\"{self.dirname}{path.sep}\"\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        frame = frameinfos[frame_no].frame\n        filename = path.realpath(frame.f_code.co_filename)\n\n        return filename.startswith(self.dirname)\n\n\nclass IgnoreStdlib(IgnoreDirname, attrs=[\"dirname\"]):\n    \"\"\"Ignore standard libraries in sysconfig.get_python_lib(standard_lib=True)\n\n    But we need to ignore 3rd-party packages under site-packages/.\n    \"\"\"\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        frame = frameinfos[frame_no].frame\n        third_party_lib = f\"{self.dirname}site-packages{path.sep}\"\n        filename = path.realpath(frame.f_code.co_filename)\n\n        return (\n            filename.startswith(self.dirname)\n            # Exclude 3rd-party libraries in site-packages\n            and not filename.startswith(third_party_lib)\n        )\n\n\nclass IgnoreFunction(IgnoreElem, attrs=[\"func\"]):\n    \"\"\"Ignore a non-decorated function\"\"\"\n\n    def _post_init(self) -&gt; None:\n        if (\n            # without functools.wraps\n            \"&lt;locals&gt;\" in self.func.__qualname__\n            or self.func.__name__ != self.func.__code__.co_name\n        ):\n            warnings.warn(\n                f\"You asked varname to ignore function {self.func.__name__!r}, \"\n                \"which may be decorated. If it is not intended, you may need \"\n                \"to ignore all intermediate frames with a tuple of \"\n                \"the function and the number of its decorators.\",\n                MaybeDecoratedFunctionWarning,\n            )\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        frame = frameinfos[frame_no].frame\n        return frame.f_code == self.func.__code__\n\n\nclass IgnoreDecorated(IgnoreElem, attrs=[\"func\", \"n_decor\"]):\n    \"\"\"Ignore a decorated function\"\"\"\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        try:\n            frame = frameinfos[frame_no + self.n_decor].frame\n        except IndexError:\n            return False\n\n        return frame.f_code == self.func.__code__\n\n\nclass IgnoreModuleQualname(IgnoreElem, attrs=[\"module\", \"qualname\"]):\n    \"\"\"Ignore calls by qualified name in the module\"\"\"\n\n    def _post_init(self) -&gt; None:\n\n        attach_ignore_id_to_module(self.module)\n        # check uniqueness of qualname\n        modfile = getattr(self.module, \"__file__\", None)\n        if modfile is not None:\n            check_qualname_by_source(\n                Source.for_filename(modfile, self.module.__dict__),\n                self.module.__name__,\n                self.qualname,\n            )\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        frame = frameinfos[frame_no].frame\n        module = cached_getmodule(frame.f_code)\n\n        # Return earlier to avoid qualname uniqueness check\n        if module and module != self.module:\n            return False\n\n        if not module and not frame_matches_module_by_ignore_id(\n            frame, self.module\n        ):\n            return False\n\n        source = Source.for_frame(frame)\n        check_qualname_by_source(source, self.module.__name__, self.qualname)\n\n        return fnmatch(source.code_qualname(frame.f_code), self.qualname)\n\n\nclass IgnoreFilenameQualname(IgnoreElem, attrs=[\"filename\", \"qualname\"]):\n    \"\"\"Ignore calls with given qualname in the module with the filename\"\"\"\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        frame = frameinfos[frame_no].frame\n\n        frame_filename = path.realpath(frame.f_code.co_filename)\n        preset_filename = path.realpath(self.filename)\n        # return earlier to avoid qualname uniqueness check\n        if frame_filename != preset_filename:\n            return False\n\n        source = Source.for_frame(frame)\n        check_qualname_by_source(source, self.filename, self.qualname)\n\n        return fnmatch(source.code_qualname(frame.f_code), self.qualname)\n\n\nclass IgnoreOnlyQualname(IgnoreElem, attrs=[\"_none\", \"qualname\"]):\n    \"\"\"Ignore calls that match the given qualname, across all frames.\"\"\"\n\n    def match(self, frame_no: int, frameinfos: List[inspect.FrameInfo]) -&gt; bool:\n        frame = frameinfos[frame_no].frame\n\n        # module is None, check qualname only\n        return fnmatch(\n            Source.for_frame(frame).code_qualname(frame.f_code), self.qualname\n        )\n\n\ndef create_ignore_elem(ignore_elem: IgnoreElemType) -&gt; IgnoreElem:\n    \"\"\"Create an ignore element according to the type\"\"\"\n    if isinstance(ignore_elem, ModuleType):\n        return IgnoreModule(ignore_elem)  # type: ignore\n    if isinstance(ignore_elem, (Path, str)):\n        return (\n            IgnoreDirname(ignore_elem)  # type: ignore\n            if path.isdir(ignore_elem)\n            else IgnoreFilename(ignore_elem)  # type: ignore\n        )\n    if hasattr(ignore_elem, \"__code__\"):\n        return IgnoreFunction(ignore_elem)  # type: ignore\n    if not isinstance(ignore_elem, tuple) or len(ignore_elem) != 2:\n        raise ValueError(f\"Unexpected ignore item: {ignore_elem!r}\")\n    # is tuple and len == 2\n    if hasattr(ignore_elem[0], \"__code__\") and isinstance(ignore_elem[1], int):\n        return IgnoreDecorated(*ignore_elem)  # type: ignore\n    # otherwise, the second element should be qualname\n    if not isinstance(ignore_elem[1], str):\n        raise ValueError(f\"Unexpected ignore item: {ignore_elem!r}\")\n\n    if isinstance(ignore_elem[0], ModuleType):\n        return IgnoreModuleQualname(*ignore_elem)  # type: ignore\n    if isinstance(ignore_elem[0], (Path, str)):\n        return IgnoreFilenameQualname(*ignore_elem)  # type: ignore\n    if ignore_elem[0] is None:\n        return IgnoreOnlyQualname(*ignore_elem)\n\n    raise ValueError(f\"Unexpected ignore item: {ignore_elem!r}\")\n\n\nclass IgnoreList:\n    \"\"\"The ignore list to match the frames to see if they should be ignored\"\"\"\n\n    @classmethod\n    def create(\n        cls,\n        ignore: IgnoreType = None,\n        ignore_lambda: bool = True,\n        ignore_varname: bool = True,\n    ) -&gt; \"IgnoreList\":\n        \"\"\"Create an IgnoreList object\n\n        Args:\n            ignore: An element of the ignore list, either\n                A module (or filename of a module)\n                A tuple of module (or filename) and qualified name\n                A function\n                A tuple of function and number of decorators\n            ignore_lambda: whether ignore lambda functions\n            ignore_varname: whether the calls from this package\n\n        Returns:\n            The IgnoreList object\n        \"\"\"\n        ignore = ignore or []\n        if not isinstance(ignore, list):\n            ignore = [ignore]\n\n        ignore_list = [\n            IgnoreStdlib(STANDLIB_PATH)  # type: ignore\n        ]  # type: List[IgnoreElem]\n        if ignore_varname:\n            ignore_list.append(create_ignore_elem(sys.modules[__package__]))\n        if ignore_lambda:\n            ignore_list.append(create_ignore_elem((None, \"*&lt;lambda&gt;\")))\n        for ignore_elem in ignore:\n            ignore_list.append(create_ignore_elem(ignore_elem))\n\n        return cls(ignore_list)  # type: ignore\n\n    def __init__(self, ignore_list: List[IgnoreElemType]) -&gt; None:\n        self.ignore_list = ignore_list\n        debug_ignore_frame(\"&gt;&gt;&gt; IgnoreList initiated &lt;&lt;&lt;\")\n\n    def nextframe_to_check(\n        self, frame_no: int, frameinfos: List[inspect.FrameInfo]\n    ) -&gt; int:\n        \"\"\"Find the next frame to check\n\n        In modst cases, the next frame to check is the next adjacent frame.\n        But for IgnoreDecorated, the next frame to check should be the next\n        `ignore[1]`th frame.\n\n        Args:\n            frame_no: The index of current frame to check\n            frameinfos: The frame info objects\n\n        Returns:\n            A number for Next `N`th frame to check. 0 if no frame matched.\n        \"\"\"\n        for ignore_elem in self.ignore_list:\n            matched = ignore_elem.match(frame_no, frameinfos)  # type: ignore\n            if matched and isinstance(ignore_elem, IgnoreDecorated):\n                debug_ignore_frame(\n                    f\"Ignored by {ignore_elem!r}\", frameinfos[frame_no]\n                )\n                return ignore_elem.n_decor + 1\n\n            if matched:\n                debug_ignore_frame(\n                    f\"Ignored by {ignore_elem!r}\", frameinfos[frame_no]\n                )\n                return 1\n        return 0\n\n    def get_frame(self, frame_no: int) -&gt; FrameType:\n        \"\"\"Get the right frame by the frame number\n\n        Args:\n            frame_no: The index of the frame to get\n\n        Returns:\n            The desired frame\n\n        Raises:\n            VarnameRetrievingError: if any exceptions raised during the process.\n        \"\"\"\n        try:\n            # since this function will be called by APIs\n            # so we should skip that\n            frames = inspect.getouterframes(sys._getframe(2), 0)\n            i = 0\n\n            while i &lt; len(frames):\n                nextframe = self.nextframe_to_check(i, frames)\n                # ignored\n                if nextframe &gt; 0:\n                    i += nextframe\n                    continue\n\n                frame_no -= 1\n                if frame_no == 0:\n                    debug_ignore_frame(\"Gotcha!\", frames[i])\n                    return frames[i].frame\n\n                debug_ignore_frame(\n                    f\"Skipping ({frame_no - 1} more to skip)\", frames[i]\n                )\n                i += 1\n\n        except Exception as exc:\n            from .utils import VarnameRetrievingError\n\n            raise VarnameRetrievingError from exc\n\n        return None  # pragma: no cover\n</code></pre>"},{"location":"api/source/varname/","title":"varname","text":""},{"location":"api/source/varname/","title":"SOURCE CODE varname DOCS","text":"<pre><code>\"\"\"Dark magics about variable names in python\"\"\"\n\nfrom .utils import (\n    config,\n    VarnameException,\n    VarnameRetrievingError,\n    ImproperUseError,\n    QualnameNonUniqueError,\n    VarnameWarning,\n    MultiTargetAssignmentWarning,\n    MaybeDecoratedFunctionWarning,\n    UsingExecWarning,\n)\nfrom .core import varname, nameof, will, argname\n\n__version__ = \"0.15.0\"\n</code></pre>"},{"location":"api/source/varname.utils/","title":"varname.utils","text":""},{"location":"api/source/varname.utils/","title":"SOURCE CODE varname.utils DOCS","text":"<pre><code>\"\"\"Some internal utilities for varname\n\n\nAttributes:\n\n    IgnoreElemType: The type for ignore elements\n    IgnoreType: The type for the ignore argument\n    MODULE_IGNORE_ID_NAME: The name of the ignore id injected to the module.\n        Espectially for modules that can't be retrieved by\n        `inspect.getmodule(frame)`\n\"\"\"\nimport sys\nimport dis\nimport ast\nimport warnings\nimport inspect\nfrom os import path\nfrom pathlib import Path\nfrom functools import lru_cache, singledispatch\nfrom types import ModuleType, FunctionType, CodeType, FrameType\nfrom typing import Tuple, Union, List, Mapping, Callable, Dict\n\nif sys.version_info &lt; (3, 10):\n    from typing_extensions import TypeAlias  # pragma: no cover\nelse:\n    from typing import TypeAlias\n\nfrom executing import Source\n\nOP2MAGIC = {\n    ast.Add: \"__add__\",\n    ast.Sub: \"__sub__\",\n    ast.Mult: \"__mul__\",\n    ast.Div: \"__truediv__\",\n    ast.FloorDiv: \"__floordiv__\",\n    ast.Mod: \"__mod__\",\n    ast.Pow: \"__pow__\",\n    ast.LShift: \"__lshift__\",\n    ast.RShift: \"__rshift__\",\n    ast.BitOr: \"__or__\",\n    ast.BitXor: \"__xor__\",\n    ast.BitAnd: \"__and__\",\n    ast.MatMult: \"__matmul__\",\n}\n\nCMP2MAGIC = {\n    ast.Eq: \"__eq__\",\n    ast.NotEq: \"__ne__\",\n    ast.Lt: \"__lt__\",\n    ast.LtE: \"__le__\",\n    ast.Gt: \"__gt__\",\n    ast.GtE: \"__ge__\",\n}\n\nIgnoreElemType = Union[\n    # module\n    ModuleType,\n    # filename of a module\n    str,\n    Path,\n    FunctionType,\n    # the module (filename) and qualname\n    # If module is None, then all qualname matches the 2nd element\n    # will be ignored. Used to ignore &lt;lambda&gt; internally\n    Tuple[Union[ModuleType, str], str],\n    # Function and number of its decorators\n    Tuple[FunctionType, int],\n]\nIgnoreType = Union[IgnoreElemType, List[IgnoreElemType]]\n\nArgSourceType: TypeAlias = Union[ast.AST, str]\nArgSourceType: TypeAlias = Union[ArgSourceType, Tuple[ArgSourceType, ...]]\nArgSourceType: TypeAlias = Union[ArgSourceType, Mapping[str, ArgSourceType]]\n\nif sys.version_info &gt;= (3, 8):\n    ASSIGN_TYPES = (ast.Assign, ast.AnnAssign, ast.NamedExpr)\n    AssignType: TypeAlias = Union[ASSIGN_TYPES]  # type: ignore\nelse:  # pragma: no cover  # Python &lt; 3.8\n    ASSIGN_TYPES = (ast.Assign, ast.AnnAssign)\n    AssignType: TypeAlias = Union[ASSIGN_TYPES]  # type: ignore\n\nPY311 = sys.version_info &gt;= (3, 11)\nMODULE_IGNORE_ID_NAME = \"__varname_ignore_id__\"\n\n\nclass config:DOCS\n    \"\"\"Global configurations for varname\n\n    Attributes:\n        debug: Show debug information for frames being ignored\n    \"\"\"\n\n    debug = False\n\n\nclass VarnameException(Exception):DOCS\n    \"\"\"Root exception for all varname exceptions\"\"\"\n\n\nclass VarnameRetrievingError(VarnameException):DOCS\n    \"\"\"When failed to retrieve the varname\"\"\"\n\n\nclass QualnameNonUniqueError(VarnameException):DOCS\n    \"\"\"When a qualified name is used as an ignore element but references to\n    multiple objects in a module\"\"\"\n\n\nclass ImproperUseError(VarnameException):DOCS\n    \"\"\"When varname() is improperly used\"\"\"\n\n\nclass VarnameWarning(Warning):DOCS\n    \"\"\"Root warning for all varname warnings\"\"\"\n\n\nclass MaybeDecoratedFunctionWarning(VarnameWarning):DOCS\n    \"\"\"When a suspecious decorated function used as ignore function directly\"\"\"\n\n\nclass MultiTargetAssignmentWarning(VarnameWarning):DOCS\n    \"\"\"When varname tries to retrieve variable name in\n    a multi-target assignment\"\"\"\n\n\nclass UsingExecWarning(VarnameWarning):DOCS\n    \"\"\"When exec is used to retrieve function name for `argname()`\"\"\"\n\n\n@lru_cache()DOCS\ndef cached_getmodule(codeobj: CodeType):\n    \"\"\"Cached version of inspect.getmodule\"\"\"\n    return inspect.getmodule(codeobj)\n\n\ndef get_node(DOCS\n    frame: int,\n    ignore: IgnoreType = None,\n    raise_exc: bool = True,\n    ignore_lambda: bool = True,\n) -&gt; ast.AST:\n    \"\"\"Try to get node from the executing object.\n\n    This can fail when a frame is failed to retrieve.\n    One case should be when python code is executed in\n    R pacakge `reticulate`, where only first frame is kept.\n\n    When the node can not be retrieved, try to return the first statement.\n    \"\"\"\n    from .ignore import IgnoreList\n\n    ignore = IgnoreList.create(ignore, ignore_lambda=ignore_lambda)\n    try:\n        frameobj = ignore.get_frame(frame)\n    except VarnameRetrievingError:\n        return None\n\n    return get_node_by_frame(frameobj, raise_exc)\n\n\ndef get_node_by_frame(frame: FrameType, raise_exc: bool = True) -&gt; ast.AST:DOCS\n    \"\"\"Get the node by frame, raise errors if possible\"\"\"\n    exect = Source.executing(frame)\n\n    if exect.node:\n        # attach the frame for better exception message\n        # (ie. where ImproperUseError happens)\n        exect.node.__frame__ = frame\n        return exect.node\n\n    if exect.source.text and exect.source.tree and raise_exc:  # pragma: no cover\n        raise VarnameRetrievingError(\n            \"Couldn't retrieve the call node. \"\n            \"This may happen if you're using some other AST magic at the \"\n            \"same time, such as pytest, ipython, macropy, or birdseye.\"\n        )\n\n    return None\n\n\ndef lookfor_parent_assign(node: ast.AST, strict: bool = True) -&gt; AssignType:DOCS\n    \"\"\"Look for an ast.Assign node in the parents\"\"\"\n    while hasattr(node, \"parent\"):\n        node = node.parent\n\n        if isinstance(node, ASSIGN_TYPES):\n            return node\n\n        if strict:\n            break\n    return None\n\n\ndef node_name(DOCS\n    node: ast.AST,\n    subscript_slice: bool = False,\n) -&gt; Union[str, Tuple[Union[str, Tuple], ...]]:\n    \"\"\"Get the node node name.\n\n    Raises ImproperUseError when failed\n    \"\"\"\n    if isinstance(node, ast.Name):\n        return node.id\n    if isinstance(node, ast.Attribute):\n        return f\"{node_name(node.value)}.{node.attr}\"\n    if isinstance(node, ast.Constant):\n        return repr(node.value)\n    if isinstance(node, (ast.List, ast.Tuple)) and not subscript_slice:\n        return tuple(node_name(elem) for elem in node.elts)\n    if isinstance(node, ast.List):\n        return f\"[{', '.join(node_name(elem) for elem in node.elts)}]\"  # type: ignore\n    if isinstance(node, ast.Tuple):\n        if len(node.elts) == 1:\n            return f\"({node_name(node.elts[0])},)\"\n        return f\"({', '.join(node_name(elem) for elem in node.elts)})\"  # type: ignore\n    if isinstance(node, ast.Starred):\n        return f\"*{node_name(node.value)}\"\n    if isinstance(node, ast.Slice):\n        return (\n            f\"{node_name(node.lower)}:{node_name(node.upper)}:{node_name(node.step)}\"\n            if node.lower is not None\n            and node.upper is not None\n            and node.step is not None\n            else f\"{node_name(node.lower)}:{node_name(node.upper)}\"\n            if node.lower is not None and node.upper is not None\n            else f\"{node_name(node.lower)}:\"\n            if node.lower is not None\n            else f\":{node_name(node.upper)}\"\n            if node.upper is not None\n            else \":\"\n        )\n\n    name = type(node).__name__\n    if isinstance(node, ast.Subscript):\n        try:\n            return f\"{node_name(node.value)}[{node_name(node.slice, True)}]\"\n        except ImproperUseError:\n            name = f\"{node_name(node.value)}[{type(node.slice).__name__}]\"\n\n    raise ImproperUseError(\n        f\"Node {name!r} detected, but only following nodes are supported: \\n\"\n        \"  - ast.Name (e.g. x)\\n\"\n        \"  - ast.Attribute (e.g. x.y, x be other supported nodes)\\n\"\n        \"  - ast.Constant (e.g. 1, 'a')\\n\"\n        \"  - ast.List (e.g. [x, y, z])\\n\"\n        \"  - ast.Tuple (e.g. (x, y, z))\\n\"\n        \"  - ast.Starred (e.g. *x)\\n\"\n        \"  - ast.Subscript with slice of the above nodes (e.g. x[y])\"\n    )\n\n\n@lru_cache()DOCS\ndef bytecode_nameof(code: CodeType, offset: int) -&gt; str:\n    \"\"\"Cached Bytecode version of nameof\n\n    We are trying this version only when the sourcecode is unavisible. In most\n    cases, this will happen when user is trying to run a script in REPL/\n    python shell, with `eval`, or other circumstances where the code is\n    manipulated to run but sourcecode is not available.\n    \"\"\"\n    kwargs: Dict[str, bool] = (\n        {\"show_caches\": True} if sys.version_info[:2] &gt;= (3, 11) else {}\n    )\n\n    instructions = list(dis.get_instructions(code, **kwargs))\n    ((current_instruction_index, current_instruction),) = (\n        (index, instruction)\n        for index, instruction in enumerate(instructions)\n        if instruction.offset == offset\n    )\n\n    while current_instruction.opname == \"CACHE\":  # pragma: no cover\n        current_instruction_index -= 1\n        current_instruction = instructions[current_instruction_index]\n\n    pos_only_error = VarnameRetrievingError(\n        \"'nameof' can only be called with a single positional argument \"\n        \"when source code is not avaiable.\"\n    )\n    if current_instruction.opname in (  # pragma: no cover\n        \"CALL_FUNCTION_EX\",\n        \"CALL_FUNCTION_KW\",\n    ):\n        raise pos_only_error\n\n    if current_instruction.opname not in (\n        \"CALL_FUNCTION\",\n        \"CALL_METHOD\",\n        \"CALL\",\n        \"CALL_KW\",\n    ):\n        raise VarnameRetrievingError(\"Did you call 'nameof' in a weird way?\")\n\n    current_instruction_index -= 1\n    name_instruction = instructions[current_instruction_index]\n    while name_instruction.opname in (\"CACHE\", \"PRECALL\"):  # pragma: no cover\n        current_instruction_index -= 1\n        name_instruction = instructions[current_instruction_index]\n\n    if name_instruction.opname in (\"KW_NAMES\", \"LOAD_CONST\"):  # LOAD_CONST python 3.13\n        raise pos_only_error\n\n    if not name_instruction.opname.startswith(\"LOAD_\"):\n        raise VarnameRetrievingError(\"Argument must be a variable or attribute\")\n\n    name = name_instruction.argrepr\n    if not name.isidentifier():\n        raise VarnameRetrievingError(\n            f\"Found the variable name {name!r} which is obviously wrong. \"\n            \"This may happen if you're using some other AST magic at the \"\n            \"same time, such as pytest, ipython, macropy, or birdseye.\"\n        )\n\n    return name\n\n\ndef attach_ignore_id_to_module(module: ModuleType) -&gt; None:DOCS\n    \"\"\"Attach the ignore id to module\n\n    This is useful when a module cannot be retrieved by frames using\n    `inspect.getmodule`, then we can use this id, which will exist in\n    `frame.f_globals` to check if the module matches in ignore.\n\n    Do it only when the __file__ is not avaiable or does not exist for\n    the module. Since this probably means the source is not avaiable and\n    `inspect.getmodule` would not work\n    \"\"\"\n    module_file = getattr(module, \"__file__\", None)\n    if module_file is not None and path.isfile(module_file):\n        return\n    # or it's already been set\n    if hasattr(module, MODULE_IGNORE_ID_NAME):\n        return\n\n    setattr(module, MODULE_IGNORE_ID_NAME, f\"&lt;varname-ignore-{id(module)})\")\n\n\ndef frame_matches_module_by_ignore_id(DOCS\n    frame: FrameType, module: ModuleType\n) -&gt; bool:\n    \"\"\"Check if the frame is from the module by ignore id\"\"\"\n    ignore_id_attached = getattr(module, MODULE_IGNORE_ID_NAME, object())\n    ignore_id_from_frame = frame.f_globals.get(MODULE_IGNORE_ID_NAME, object())\n    return ignore_id_attached == ignore_id_from_frame\n\n\n@lru_cache()DOCS\ndef check_qualname_by_source(\n    source: Source, modname: str, qualname: str\n) -&gt; None:\n    \"\"\"Check if a qualname in module is unique\"\"\"\n    if not source.tree:\n        # no way to check it, skip\n        return\n    nobj = list(source._qualnames.values()).count(qualname)\n    if nobj &gt; 1:\n        raise QualnameNonUniqueError(\n            f\"Qualname {qualname!r} in \"\n            f\"{modname!r} refers to multiple objects.\"\n        )\n\n\ndef debug_ignore_frame(msg: str, frameinfo: inspect.FrameInfo = None) -&gt; None:DOCS\n    \"\"\"Print the debug message for a given frame info object\n\n    Args:\n        msg: The debugging message\n        frameinfo: The FrameInfo object for the frame\n    \"\"\"\n    if not config.debug:\n        return\n    if frameinfo is not None:\n        msg = (\n            f\"{msg} [In {frameinfo.function!r} at \"\n            f\"{frameinfo.filename}:{frameinfo.lineno}]\"\n        )\n    sys.stderr.write(f\"[{__package__}] DEBUG: {msg}\\n\")\n\n\ndef argnode_source(DOCS\n    source: Source, node: ast.AST, vars_only: bool\n) -&gt; Union[str, ast.AST]:\n    \"\"\"Get the source of an argument node\n\n    Args:\n        source: The executing source object\n        node: The node to get the source from\n        vars_only: Whether only allow variables and attributes\n\n    Returns:\n        The source of the node (node.id for ast.Name,\n            node.attr for ast.Attribute). Or the node itself if the source\n            cannot be fetched.\n    \"\"\"\n    if isinstance(node, ast.Constant):\n        return repr(node.value)\n\n    if sys.version_info &lt; (3, 9):  # pragma: no cover\n        if isinstance(node, ast.Index):\n            node = node.value\n        if isinstance(node, ast.Num):\n            return repr(node.n)\n        if isinstance(node, (ast.Bytes, ast.Str)):\n            return repr(node.s)\n        if isinstance(node, ast.NameConstant):\n            return repr(node.value)\n\n    if vars_only:\n        return (\n            node.id\n            if isinstance(node, ast.Name)\n            else node.attr\n            if isinstance(node, ast.Attribute)\n            else node\n        )\n\n    # requires asttokens\n    return source.asttokens().get_text(node)\n\n\ndef get_argument_sources(DOCS\n    source: Source,\n    node: ast.Call,\n    func: Callable,\n    vars_only: bool,\n) -&gt; Mapping[str, ArgSourceType]:\n    \"\"\"Get the sources for argument from an ast.Call node\n\n    &gt;&gt;&gt; def func(a, b, c, d=4):\n    &gt;&gt;&gt;  ...\n    &gt;&gt;&gt; x = y = z = 1\n    &gt;&gt;&gt; func(y, x, c=z)\n    &gt;&gt;&gt; # argument_sources = {'a': 'y', 'b', 'x', 'c': 'z'}\n    &gt;&gt;&gt; func(y, x, c=1)\n    &gt;&gt;&gt; # argument_sources = {'a': 'y', 'b', 'x', 'c': ast.Num(n=1)}\n    \"\"\"\n    # &lt;Signature (a, b, c, d=4)&gt;\n    signature = inspect.signature(func, follow_wrapped=False)\n    # func(y, x, c=z)\n    # ['y', 'x'], {'c': 'z'}\n    arg_sources = [\n        argnode_source(source, argnode, vars_only) for argnode in node.args\n    ]\n    kwarg_sources = {\n        argnode.arg: argnode_source(source, argnode.value, vars_only)\n        for argnode in node.keywords\n        if argnode.arg is not None\n    }\n    bound_args = signature.bind_partial(*arg_sources, **kwarg_sources)\n    argument_sources = bound_args.arguments\n    # see if *args and **kwargs have anything assigned\n    # if not, assign () and {} to them\n    for parameter in signature.parameters.values():\n        if parameter.kind == inspect.Parameter.VAR_POSITIONAL:\n            argument_sources.setdefault(parameter.name, ())\n        if parameter.kind == inspect.Parameter.VAR_KEYWORD:\n            argument_sources.setdefault(parameter.name, {})\n    return argument_sources\n\n\ndef get_function_called_argname(frame: FrameType, node: ast.Call) -&gt; Callable:DOCS\n    \"\"\"Get the function who called argname\"\"\"\n    # variable\n    if isinstance(node.func, ast.Name):\n        func = frame.f_locals.get(\n            node.func.id, frame.f_globals.get(node.func.id)\n        )\n        if func is None:  # pragma: no cover\n            # not sure how it would happen but in case\n            raise VarnameRetrievingError(\n                f\"Cannot retrieve the function by {node.func.id!r}.\"\n            )\n        return func\n\n    # use pure_eval\n    pure_eval_fail_msg = None\n    try:\n        from pure_eval import Evaluator, CannotEval\n    except ImportError:\n        pure_eval_fail_msg = \"'pure_eval' is not installed.\"\n    else:\n        try:\n            evaluator = Evaluator.from_frame(frame)\n            return evaluator[node.func]\n        except CannotEval:\n            pure_eval_fail_msg = (\n                f\"Cannot evaluate node {ast.dump(node.func)} \"\n                \"using 'pure_eval'.\"\n            )\n\n    # try eval\n    warnings.warn(\n        f\"{pure_eval_fail_msg} \"\n        \"Using 'eval' to get the function that calls 'argname'. \"\n        \"Try calling it using a variable reference to the function, or \"\n        \"passing the function to 'argname' explicitly.\",\n        UsingExecWarning,\n    )\n    expr = ast.Expression(node.func)\n    code = compile(expr, \"&lt;ast-call&gt;\", \"eval\")\n    return eval(code, frame.f_globals, frame.f_locals)\n\n\n@singledispatchDOCS\ndef reconstruct_func_node(node: ast.AST) -&gt; ast.Call:\n    \"\"\"Reconstruct the ast.Call node from\n\n    `x.a` to `x.__getattr__('a')`\n    `x.a = b` to `x.__setattr__('a', b)`\n    `x[a]` to `x.__getitem__(a)`\n    `x[a] = b` to `x.__setitem__(a, 1)`\n    `x + a` to `x.__add__(a)`\n    `x &lt; a` to `x.__lt__(a)`\n    \"\"\"\n    raise VarnameRetrievingError(\n        f\"Cannot reconstruct ast.Call node from {type(node).__name__}, \"\n        \"expecting Call, Attribute, Subscript, BinOp, Compare.\"\n    )\n\n\n@reconstruct_func_node.register(ast.Call)\ndef _(node: ast.Call) -&gt; ast.Call:\n    return node\n\n\n@reconstruct_func_node.register(ast.Attribute)\n@reconstruct_func_node.register(ast.Subscript)\ndef _(node: Union[ast.Attribute, ast.Subscript]) -&gt; ast.Call:\n    \"\"\"Reconstruct the function node for\n    `x.__getitem__/__setitem__/__getattr__/__setattr__`\"\"\"\n    nodemeta = {\n        \"lineno\": node.lineno,\n        \"col_offset\": node.col_offset,\n    }\n    keynode = (\n        node.slice\n        if isinstance(node, ast.Subscript)\n        else ast.Constant(value=node.attr)\n    )\n\n    # x[1], x.a\n    if isinstance(node.ctx, ast.Load):\n        if PY311:\n            return ast.Call(\n                func=ast.Attribute(\n                    value=node.value,\n                    attr=(\n                        \"__getitem__\"\n                        if isinstance(node, ast.Subscript)\n                        else \"__getattr__\"\n                    ),\n                    ctx=ast.Load(),\n                    **nodemeta,\n                ),\n                args=[keynode],\n                keywords=[],\n            )\n        else:  # pragma: no cover\n            return ast.Call(  # type: ignore\n                func=ast.Attribute(\n                    value=node.value,\n                    attr=(\n                        \"__getitem__\"\n                        if isinstance(node, ast.Subscript)\n                        else \"__getattr__\"\n                    ),\n                    ctx=ast.Load(),\n                    **nodemeta,\n                ),\n                args=[keynode],\n                keywords=[],\n                starargs=None,\n                kwargs=None,\n            )\n\n    # x[a] = b, x.a = b\n    if (\n        not hasattr(node, \"parent\")\n        or not isinstance(node.parent, ast.Assign)  # type: ignore\n        or len(node.parent.targets) != 1  # type: ignore\n    ):\n        raise ImproperUseError(\n            rich_exc_message(\n                \"Expect `x[a] = b` or `x.a = b` directly, got \"\n                f\"{ast.dump(node)}.\",\n                node,\n            )\n        )\n\n    if PY311:\n        return ast.Call(\n            func=ast.Attribute(\n                value=node.value,\n                attr=(\n                    \"__setitem__\"\n                    if isinstance(node, ast.Subscript)\n                    else \"__setattr__\"\n                ),\n                ctx=ast.Load(),\n                **nodemeta,\n            ),\n            args=[keynode, node.parent.value],  # type: ignore\n            keywords=[],\n        )\n    else:  # pragma: no cover\n        return ast.Call(\n            func=ast.Attribute(\n                value=node.value,\n                attr=(\n                    \"__setitem__\"\n                    if isinstance(node, ast.Subscript)\n                    else \"__setattr__\"\n                ),\n                ctx=ast.Load(),\n                **nodemeta,\n            ),\n            args=[keynode, node.parent.value],  # type: ignore\n            keywords=[],\n            starargs=None,\n            kwargs=None,\n        )\n\n\n@reconstruct_func_node.register(ast.Compare)\ndef _(node: ast.Compare) -&gt; ast.Call:\n    \"\"\"Reconstruct the function node for `x &lt; a`\"\"\"\n    # When the node is identified by executing, len(ops) is always 1.\n    # Otherwise, the node cannot be identified.\n    assert len(node.ops) == 1\n\n    nodemeta = {\n        \"lineno\": node.lineno,\n        \"col_offset\": node.col_offset,\n    }\n    if PY311:\n        return ast.Call(\n            func=ast.Attribute(\n                value=node.left,\n                attr=CMP2MAGIC[type(node.ops[0])],\n                ctx=ast.Load(),\n                **nodemeta,\n            ),\n            args=[node.comparators[0]],\n            keywords=[],\n        )\n    else:  # pragma: no cover\n        return ast.Call(  # type: ignore\n            func=ast.Attribute(\n                value=node.left,\n                attr=CMP2MAGIC[type(node.ops[0])],\n                ctx=ast.Load(),\n                **nodemeta,\n            ),\n            args=[node.comparators[0]],\n            keywords=[],\n            starargs=None,\n            kwargs=None,\n        )\n\n\n@reconstruct_func_node.register(ast.BinOp)\ndef _(node: ast.BinOp) -&gt; ast.Call:\n    \"\"\"Reconstruct the function node for `x + a`\"\"\"\n    nodemeta = {\n        \"lineno\": node.lineno,\n        \"col_offset\": node.col_offset,\n    }\n\n    if PY311:\n        return ast.Call(\n            func=ast.Attribute(\n                value=node.left,\n                attr=OP2MAGIC[type(node.op)],\n                ctx=ast.Load(),\n                **nodemeta,\n            ),\n            args=[node.right],\n            keywords=[],\n        )\n    else:  # pragma: no cover\n        return ast.Call(  # type: ignore\n            func=ast.Attribute(\n                value=node.left,\n                attr=OP2MAGIC[type(node.op)],\n                ctx=ast.Load(),\n                **nodemeta,\n            ),\n            args=[node.right],\n            keywords=[],\n            starargs=None,\n            kwargs=None,\n        )\n\n\ndef rich_exc_message(msg: str, node: ast.AST, context_lines: int = 4) -&gt; str:DOCS\n    \"\"\"Attach the source code from the node to message to\n    get a rich message for exceptions\n\n    If package 'rich' is not install or 'node.__frame__' doesn't exist, fall\n    to plain message (with basic information), otherwise show a better message\n    with full information\n    \"\"\"\n    frame = node.__frame__  # type: FrameType\n    lineno = node.lineno - 1  # type: int\n    col_offset = node.col_offset  # type: int\n    filename = frame.f_code.co_filename  # type: str\n    try:\n        lines, startlineno = inspect.getsourcelines(frame)\n    except OSError:  # pragma: no cover\n        # could not get source code\n        return f\"{msg}\\n\"\n    startlineno = 0 if startlineno == 0 else startlineno - 1\n    line_range = (startlineno + 1, startlineno + len(lines) + 1)\n\n    linenos = tuple(map(str, range(*line_range)))  # type: Tuple[str, ...]\n    lineno_width = max(map(len, linenos))  # type: int\n    hiline = lineno - startlineno  # type: int\n    codes = []  # type: List[str]\n    for i, lno in enumerate(linenos):\n        if i &lt; hiline - context_lines or i &gt; hiline + context_lines:\n            continue\n        lno = lno.ljust(lineno_width)\n        if i == hiline:\n            codes.append(f\"  &gt; | {lno}  {lines[i]}\")\n            codes.append(f\"    | {' ' * (lineno_width + col_offset + 2)}^\\n\")\n        else:\n            codes.append(f\"    | {lno}  {lines[i]}\")\n\n    return (\n        f\"{msg}\\n\\n\"\n        f\"  {filename}:{lineno + 1}:{col_offset + 1}\\n\"\n        f\"{''.join(codes)}\\n\"\n    )\n</code></pre>"}]}